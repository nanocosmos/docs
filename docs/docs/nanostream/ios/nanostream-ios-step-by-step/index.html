<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Tutorial / Getting started with nanoStream and bintu.live · nanocosmos Documentation</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Overview"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Tutorial / Getting started with nanoStream and bintu.live · nanocosmos Documentation"/><meta property="og:type" content="website"/><meta property="og:url" content="https://docs.nanocosmos.de/"/><meta property="og:description" content="## Overview"/><meta property="og:image" content="https://docs.nanocosmos.de/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://docs.nanocosmos.de/img/docusaurus.png"/><link rel="shortcut icon" href="/img/favicon_nano.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-552140-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/js/search.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/nanocosmos_header_logo.png" alt="nanocosmos Documentation"/><h2 class="headerTitleWithLogo">nanocosmos Documentation</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/cloud/cloud_overview" target="_self">nanoStream Cloud</a></li><li class=""><a href="/docs/nanoplayer/nanoplayer_introduction" target="_self">H5Live Player</a></li><li class=""><a href="/docs/webrtc/nanostream_webrtc_introduction" target="_self">nanoStream Webcaster</a></li><li class="siteNavGroupActive"><a href="/docs/nanostream/nanostream" target="_self">nanoStream Apps and SDKs</a></li><li class=""><a href="/docs/samples/samples" target="_self">Samples</a></li><li class=""><a href="/docs/faq/faq_streaming" target="_self">FAQ</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>iOS</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">nanoStream SDKs/Apps</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/nanostream/nanostream">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Android</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/nanostream/android/nanostream_android_getting_started">Getting started</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/android/nanostream_android_developer_manual_playback">Playback</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/android/nanostream_android_developer_manual_streaming">Streaming Media</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/android/nanostream_android_developer_manual_sample">Sample</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">iOS</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/nanostream/ios/nanostream_ios_quick_start">Developer Quickstart</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/nanostream/ios/nanostream-ios-step-by-step">Getting started</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/ios/nanostream_ios_sdk">SDK for iOS</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/ios/bintu_ios_sdk">bintu.live client SDK</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/ios/bintu_ios_sample">iOS Streaming App in 5 Minutes</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/ios/nanostream_ios_license_deployment">License Deployment Information</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Windows</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_windows_binaries">Binary Modules for Windows</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_windows_developer_manual">Developer Manual</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_windows_language_integration">nanoStream Windows Language Integration</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_windows_license_help">Setting the license</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_windows_networkwriter">RTMP Network Renderer &amp; Writer</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_encoder_plugin_api">Encoder Plugin API</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">DirectShow</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/nanostream_directshow_h264">H264</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/nanostream_directshow_rtmp">RTMP</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/directshow_rtmp_writer">RTMP Writer</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/nanostream_directshow_rtsp">RTSP</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/nanostream_directshow_udp_streaming">UDP/TS Streaming</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/nanostream_directshow_video_filter">Video Filter</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/nanocosmos/docs/tree/master/docs/nanostream/ios/nanostream-ios-step-by-step.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Tutorial / Getting started with nanoStream and bintu.live</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="overview"></a><a href="#overview" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview</h2>
<p>In this guide you will learn how to to build a live video broadcaster app with nanoStream that streams to our bintu.live streaming platform. Learn how to create the connection to bintu and obtain streaming configuration for your client. Setup the nanoStream client SDK to use the configuration we just got and broadcast your own live stream in minutes!</p>
<p>You will learn how to build simple broadcaster and player app from the ground of with XCode for iOS, that can play the stream from our broadcaster app.</p>
<h2><a class="anchor" aria-hidden="true" id="prerequisites"></a><a href="#prerequisites" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prerequisites</h2>
<ul>
<li>nanoStream 4.6 or later, including the bintu.live streaming platform connection</li>
<li>a valid Bintu APIKey</li>
<li>a nanoStreamSDK License valid for iOS (broadcast and playback)</li>
<li>bintu.live connector requires at least iOS 8.0</li>
</ul>
<p>This tutorial is based on Mac OS X 10.11.3, Xcode 7.1 and iOS 9.1.</p>
<h1><a class="anchor" aria-hidden="true" id="bintulive-platform-connection"></a><a href="#bintulive-platform-connection" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bintu.live platform connection</h1>
<p>Our Bintu.live connection component consists of an entry point API client class <code>BNTAPIClient</code> which you use to make calls to our streaming platform. There are other class, like <code>BNTStreamInfo</code> and <code>BNTRTMPInfo</code> which mainly hold the configuration you receive from the <code>BNTAPIClient</code>.</p>
<p>In general, if you want to interface with our streaming platform, you construct an instance of the <code>BNTAPIClient</code> with its main constructor:</p>
<pre><code class="hljs">BNTAPIClient *client = [BNTAPIClient initWithAPIKey:apiKey];
</code></pre>
<p>Once you have an instance, you can create new streams with it, receive information about a previously created stream or list all streams that are present on your account.</p>
<p>Lets step through these in detail:</p>
<p>With the <code>createStream</code> call you create a new stream. You would use this in your broadcaster app. In the completion block of this method, you get an instance of <code>BNTStreamInfo</code> which exposes an instance of <code>BNTRTMPIngest</code> which holds the configuration you need to stream to bintu.live.</p>
<pre><code class="hljs">[client createStreamWithCompletion:^(BNTStreamInfo *stream, NSError *err) {
    self.streamID = stream.id;
    self.streamURL = stream.ingest.rtmpInfo.url;
    self.streamName = stream.ingest.rtmpInfo.streamName;
}];
</code></pre>
<p>With the<code>getStreamWithID</code> call you can receive information about a previously created stream. In most cases, you would take the stream ID you get while creating a stream and store it on your own server somewhere. If anyone wants to view a stream, you send that ID to the player app. Then you can receive that stream's playout information.
For example, if you want to play the stream via HLS:</p>
<pre><code class="hljs">[client getStreamWithID:@&quot;&lt;a long id&gt;&quot; andCompletion:^(BNTStreamInfo *stream, NSError *err) {
    BNTHLSPlayout *playout = [stream.hlsPlayouts firstObject];
    self.hlsURL = playout.url;
}];
</code></pre>
<p>Last but not least, you can list all streams on your account with the <code>getStreams</code> call. For example, you can bypass your server, get all streams on the player and let the user select the one they want to see. Or you just play the first one that is live, like shown below:</p>
<pre><code class="hljs">[client getStreamsWithCompletion:^(NSArray *streams, NSError *err) {
    for (BNTStreamInfo *stream in streams) {
        if (stream.state == BNTStreamStateLive) {
            // play stream!
        }
    }
}];
</code></pre>
<p>That was a basic overview of your bintu.live component. Now we show you how to build an end-to-end system with that.</p>
<h2><a class="anchor" aria-hidden="true" id="live-video-encoder-broadcast-app"></a><a href="#live-video-encoder-broadcast-app" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Live Video Encoder (broadcast) app</h2>
<h3><a class="anchor" aria-hidden="true" id="setup"></a><a href="#setup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setup</h3>
<p>Create a new Xcode project with the template &quot;Single View Application&quot;.</p>
<p>Enter your desired application name and organisation identifier. For this tutorial, our app is called &quot;StreamingExample&quot;, but you can name it anything you like. These settings do not matter right now. For this tutorial we will not create Unit or UI tests, so you can disable them for now. This guide will be in Objective-C.</p>
<p>Save the project somewhere on your computer.</p>
<p>Our app will be in portrait only. Therefore on the &quot;General&quot; tab of your application target in Xcode, under &quot;Deployment Info&quot; -&gt; &quot;Device Orientation&quot;, uncheck all except for &quot;Portrait&quot;. It should look like this:</p>
<h3><a class="anchor" aria-hidden="true" id="broadcast-view"></a><a href="#broadcast-view" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Broadcast View</h3>
<p>To create our broadcast view, go into the <code>Main.storyboard</code> file Xcode should have generated for you. It should be pretty empty right now.</p>
<p>Change the background color to any color (except white) you like so we can better see where it is.</p>
<p>This will be the view which will hold the camera preview so the user can see what is being streamed right now. We want this to cover our whole screen so we will make some adjustments to the autolayout constraints. We create four new constraints from our view to every edge of the screen. The distance should be zero for all, and margins should not be used for this.</p>
<p>Now the autolayout engine should tell us with some yellow warnings that our current view state does not reflect our constraints.</p>
<p>We will then click on the little yellow arrow next to &quot;View Controller Scene&quot; which will show us what is going wrong with the constraints.</p>
<p>After clicking on the little yellow triangle, Xcode shows us some recommended fixes for the problems. We choose &quot;Update Frames&quot; and click &quot;Fix Misplacement&quot;. This will instruct Xcode to use our constraints as guidelines and update the view accordingly, therefore expanding our preview view to cover the screen. Your storyboard should now look something like this:</p>
<p>Next we will add the button that will start and stop our stream. Add a new button to our main view, give it the title &quot;Start&quot; and give it a text color which we can see on top of our camera view.</p>
<p>The place looks a little bit off, so we will add some constraints which fix it to the bottom of the screen. Select the button and add a constraint with zero distance to the bottom margin of the screen.</p>
<p>Also add a constraint which horizontally centers the button.</p>
<p>After that, we will again use &quot;Update Frames&quot; and &quot;Fix Misplacement&quot; to make our view conform to our constraints.</p>
<h3><a class="anchor" aria-hidden="true" id="connection-to-viewcontroller"></a><a href="#connection-to-viewcontroller" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Connection to ViewController</h3>
<p>Next, enter Automatic Mode and create outlets for the broadcast button and the preview to our ViewController. Do this via holding down Ctrl and dragging from the button/view to the interface section of the <code>ViewController.m</code> file.</p>
<p>Create an action for the button by dragging from the button to the implementation part of the viewcontroller code.</p>
<p>Now we have created our view. We can now move on to importing our modules.</p>
<h3><a class="anchor" aria-hidden="true" id="importing-the-sdks"></a><a href="#importing-the-sdks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Importing the SDKs</h3>
<p>You need the following files: <code>Bintu.framework</code>, <code>libnanostreamAVC.a</code> and <code>nanostreamAVC.h</code>. Drag all files into your project in the Navigator on the left side. Check &quot;Copy items if needed&quot; for all of them.</p>
<p>Your project should now look something like this. The framework and library file should be automatically entered into the section &quot;Linked frameworks and libraries&quot;.</p>
<p>Remove the entry for <code>Bintu.framework</code> from that section (it will get readded later). Drag the <code>Bintu.framework</code> file from the Navigator to the section &quot;Embedded Binaries&quot;. This should add it to the &quot;Linked Frameworks and Libraries&quot; again.</p>
<p>If you build and run this project now on your iPhone, you should see the preview view with our colored background and the broadcast button. If you see a linker error that probably means you did not import the libraries correctly, try to do it again.</p>
<h3><a class="anchor" aria-hidden="true" id="setting-up-nanostream-sdk"></a><a href="#setting-up-nanostream-sdk" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setting up nanoStream SDK</h3>
<p>nanoStream SDK has some dependencies which you need to include, otherwise it will not compile correctly. Go to the &quot;Linked Frameworks and Libraries&quot; section of your target and add following libraries (by clicking the plus sign):</p>
<ul>
<li>CoreVideo.framework</li>
<li>libc++ (.tbd or .dylib)</li>
<li>libstdc++.6.0.9 (.tbd or .dylib)</li>
<li>AVFoundation.framework</li>
<li>CoreMedia.framework</li>
<li>libz (.tbd or .dylib)</li>
<li>UIKit.framework</li>
<li>Foundation.framework</li>
<li>CoreGraphics.framework</li>
<li>SystemConfiguration.framework</li>
<li>Accelerate.framework</li>
<li>VideoToolbox.framework (link as Optional, not as Required)</li>
<li>AudioToolbox.framework</li>
</ul>
<p>The section should now look like this:</p>
<p>Now enter your <code>ViewController.m</code> file. At this point, it looks something like this (your property names may vary):</p>
<pre><code class="hljs"><span class="hljs-comment">//</span>
<span class="hljs-comment">//  ViewController.m</span>
<span class="hljs-comment">//  StreamingExample</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  Created by nanocosmos on 18.02.16.</span>
<span class="hljs-comment">//  Copyright © 2016 exampleorganisation. All rights reserved.</span>
<span class="hljs-comment">//</span>

<span class="hljs-meta">#import <span class="hljs-meta-string">"ViewController.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIButton</span> *broadcastButton;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIView</span> *preview;

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span>

- (<span class="hljs-keyword">void</span>)viewDidLoad {
    [<span class="hljs-keyword">super</span> viewDidLoad];
    <span class="hljs-comment">// Do any additional setup after loading the view, typically from a nib.</span>
}

- (<span class="hljs-keyword">void</span>)didReceiveMemoryWarning {
    [<span class="hljs-keyword">super</span> didReceiveMemoryWarning];
    <span class="hljs-comment">// Dispose of any resources that can be recreated.</span>
}

- (<span class="hljs-keyword">IBAction</span>)toggleStreaming:(<span class="hljs-keyword">id</span>)sender {
}
<span class="hljs-keyword">@end</span>
</code></pre>
<p>Below <code>#import ViewController.h</code>, import the nanostreamSDK header like this:</p>
<pre><code class="hljs">#import &quot;nanostreamAVC.h&quot;
</code></pre>
<p>Below <code>@property (weak, nonatomic) IBOutlet UIView *preview;</code> add a property which will hold our SDK instance to the interface section.</p>
<pre><code class="hljs">@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>(strong) nanostreamAVC *streamer;
</code></pre>
<p>After the <code>viewDidLoad</code> method, add the following lines (replace the license string with the real license):</p>
<pre><code class="hljs">- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated
{
    // <span class="hljs-keyword">create</span> <span class="hljs-keyword">default</span> settings <span class="hljs-keyword">for</span> nanostream SDK
    nanostreamAVCSettings *settings = [[nanostreamAVCSettings alloc] init];

    // <span class="hljs-keyword">set</span> our stream <span class="hljs-keyword">to</span> portrait orientation, same <span class="hljs-keyword">as</span> our interface
    settings.orientation = AVCaptureVideoOrientationPortrait;

    // <span class="hljs-keyword">create</span> our nanoStream SDK instance <span class="hljs-keyword">and</span> <span class="hljs-keyword">create</span> the preview (<span class="hljs-keyword">by</span> <span class="hljs-keyword">passing</span> our preview <span class="hljs-keyword">view</span> <span class="hljs-keyword">into</span> it)
    self.streamer = [[nanostreamAVC alloc] initWithSettings:settings uiPreview:self.preview errorListener:nil];

    [self.streamer setLicense:@"&lt;your license here&gt;"];
}
</code></pre>
<p>If you build and run this on your device, the app should start and ask for camera and microphone permissions.</p>
<p>After you accept, it should look something like this, with the preview running and the broadcast button at the bottom:</p>
<h3><a class="anchor" aria-hidden="true" id="setting-up-the-bintulive-connection"></a><a href="#setting-up-the-bintulive-connection" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setting up the bintu.live connection</h3>
<p>We will now create the connection to bintu so we can get our streaming configuration.
Add the following import after <code>#import &quot;nanostreamAVC.h&quot;</code>:</p>
<pre><code class="hljs"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Bintu/Bintu.h&gt;</span></span>
</code></pre>
<p>Below <code>@property (strong) nanostreamAVC *streamer;</code>, add these three properties:</p>
<pre><code class="hljs">@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>(strong) NSString *streamURL;
@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>(strong) NSString *streamName;

@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>(strong) BNTAPIClient *client;
</code></pre>
<p>Now, add these lines to the <code>viewDidAppear:</code> method (replace the apikey string with your API key):</p>
<pre><code class="hljs">// <span class="hljs-keyword">create</span> bintu api <span class="hljs-keyword">client</span> <span class="hljs-keyword">with</span> apikey
self.client = [[BNTAPIClient alloc] initWithAPIKey:@<span class="hljs-string">"&lt;your apikey here&gt;"</span>];
</code></pre>
<p>You can now create a stream without any effort. To do this, fill out the <code>toggleStreaming:</code> method:</p>
<pre><code class="hljs">- (<span class="hljs-keyword">IBAction</span>)toggleStreaming:(<span class="hljs-keyword">id</span>)sender {
    [<span class="hljs-keyword">self</span>.client createStreamWithCompletion:^(BNTStreamInfo *stream, <span class="hljs-built_in">NSError</span> *err) {
        <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"There was an error while creating the stream: %@"</span>, err);
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">self</span>.streamURL = stream.ingest.rtmpInfo.url;
        <span class="hljs-keyword">self</span>.streamName = stream.ingest.rtmpInfo.streamName;

        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"We created a stream! StreamURL: %@, StreamName: %@"</span>, <span class="hljs-keyword">self</span>.streamURL, <span class="hljs-keyword">self</span>.streamName);
    }];
}
</code></pre>
<p>This code will create a stream via the Bintu API and return the info we need.</p>
<p>If you run your app and tap the broadcast button, after a short while you should see something logged to the console. Either there was an error or you will get a stream.
If this first test was successful, we can continue. If there was an error logged, please check your API key and your account. The error message should tell you something about the error. If not, contact us.</p>
<h3><a class="anchor" aria-hidden="true" id="putting-it-together"></a><a href="#putting-it-together" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Putting it together</h3>
<p>If the test was successful, we can now really start streaming with the configuration we got. We need to give the configuration to our nanoStream SDK and start the stream. This is done via following code which we add at the end of the completion block of our <code>createStream</code> call:</p>
<pre><code class="hljs"><span class="hljs-comment">// set the configuration we just received</span>
[<span class="hljs-keyword">self</span>.streamer setURL:<span class="hljs-keyword">self</span>.streamURL streamID:<span class="hljs-keyword">self</span>.streamName];

<span class="hljs-comment">// start the stream!</span>
[<span class="hljs-keyword">self</span>.streamer start:^(<span class="hljs-built_in">NSXError</span> error) {
    <span class="hljs-keyword">if</span> (error != <span class="hljs-built_in">NSXErrorNone</span>) {
        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"There was an error starting the stream. %ld"</span>, (<span class="hljs-keyword">long</span>)error);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// this callback is called asynchronously on a background thread/queue.</span>
    <span class="hljs-comment">// UI updates should happen on the main queue, therefore switch to it</span>
    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{

        <span class="hljs-comment">// change the button title so we know we are streaming</span>
        [<span class="hljs-keyword">self</span>.broadcastButton setTitle:<span class="hljs-string">@"Stop"</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];
    });

}];
</code></pre>
<p>Now you should be able to tap the broadcast button and stream using nanoStream SDK. If the button changes its title to &quot;Stop&quot;, everything is great. If not, check the console and your code.</p>
<p>Of course we also want to stop the stream once we started it. You can check if a stream is running with the <code>-active</code> method on our nanostream SDK. Stopping a stream is done via the <code>-stop:withCompletion:</code> method. The first parameter (&quot;blocking&quot;) tells the SDK if you want to wait for all remaining stream packets (set to <code>true</code>) to be sent or if you want the stream to end right now (set to <code>false</code>).</p>
<p>You can now wrap the contents of the <code>-toggleStreaming:</code> method with this check:</p>
<pre><code class="hljs"><span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.streamer active]) {
    <span class="hljs-comment">// stream is currently running. we want to stop it here.</span>

    [<span class="hljs-keyword">self</span>.streamer stop:<span class="hljs-literal">false</span> withCompletion:^{
        <span class="hljs-comment">// stream was stopped</span>

        <span class="hljs-comment">// update button on main queue again:</span>
        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            [<span class="hljs-keyword">self</span>.broadcastButton setTitle:<span class="hljs-string">@"Start"</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];
        });

    }];
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// stream is not running, we want to create a new one and start it</span>

    <span class="hljs-comment">// our previous code</span>

}
</code></pre>
<p>We are finished with the broadcaster! Altogether, our <code>-toggleStreaming:</code> looks like this:</p>
<pre><code class="hljs">- (<span class="hljs-keyword">IBAction</span>)toggleStreaming:(<span class="hljs-keyword">id</span>)sender {

    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.streamer active]) {
        <span class="hljs-comment">// stream is currently running. we want to stop it here.</span>

        [<span class="hljs-keyword">self</span>.streamer stop:<span class="hljs-literal">false</span> withCompletion:^{
            <span class="hljs-comment">// stream was stopped</span>

            <span class="hljs-comment">// update button on main queue again:</span>
            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
                [<span class="hljs-keyword">self</span>.broadcastButton setTitle:<span class="hljs-string">@"Start"</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];
            });

        }];
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// stream is not running, we want to create a new one and start it</span>


        [<span class="hljs-keyword">self</span>.client createStreamWithCompletion:^(BNTStreamInfo *stream, <span class="hljs-built_in">NSError</span> *err) {
            <span class="hljs-keyword">if</span> (err) {
                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"There was an error while creating the stream: %@"</span>, err);
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">self</span>.streamURL = stream.ingest.rtmpInfo.url;
            <span class="hljs-keyword">self</span>.streamName = stream.ingest.rtmpInfo.streamName;

            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"We created a stream! StreamURL: %@, StreamName: %@"</span>, <span class="hljs-keyword">self</span>.streamURL, <span class="hljs-keyword">self</span>.streamName);

            <span class="hljs-comment">// set the configuration we just received</span>
            [<span class="hljs-keyword">self</span>.streamer setURL:<span class="hljs-keyword">self</span>.streamURL streamID:<span class="hljs-keyword">self</span>.streamName];

            <span class="hljs-comment">// start the stream!</span>
            [<span class="hljs-keyword">self</span>.streamer start:^(<span class="hljs-built_in">NSXError</span> error) {
                <span class="hljs-keyword">if</span> (error != <span class="hljs-built_in">NSXErrorNone</span>) {
                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"There was an error starting the stream. %ld"</span>, (<span class="hljs-keyword">long</span>)error);
                    <span class="hljs-keyword">return</span>;
                }

                <span class="hljs-comment">// this callback is called asynchronously on a background thread/queue.</span>
                <span class="hljs-comment">// UI updates should happen on the main queue, therefore switch to it</span>
                <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{

                    <span class="hljs-comment">// change the button title so we know we are streaming</span>
                    [<span class="hljs-keyword">self</span>.broadcastButton setTitle:<span class="hljs-string">@"Stop"</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];
                });

            }];
        }];

    }

}
</code></pre>
<p>You can find the complete broadcaster sample project in the SDK-folder, at <code>samples/SimpleEncoder</code>. That sample also includes additional error handling and error surfacing, which has been omitted from this guide for brevity.</p>
<h2><a class="anchor" aria-hidden="true" id="playing-app"></a><a href="#playing-app" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Playing App</h2>
<h3><a class="anchor" aria-hidden="true" id="setup-1"></a><a href="#setup-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setup</h3>
<p>Again, create a new Xcode project with the template &quot;Single View Application&quot;.</p>
<p>We will name this app &quot;PlayingExample&quot;. Again, disable Unit Tests and UI Tests.</p>
<p>Save the project somewhere on your computer where you can find it later.</p>
<p>To correspond with our broadcaster streaming in portrait orientation, the player will also be in portrait mode only. Therefore on the &quot;General&quot; tab of your application target in Xcode, under &quot;Deployment Info&quot; -&gt; &quot;Device Orientation&quot;, uncheck all except for &quot;Portrait&quot;. It should look like this:</p>
<h3><a class="anchor" aria-hidden="true" id="playing-view"></a><a href="#playing-view" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Playing View</h3>
<p>To create our playing view, go into the <code>Main.storyboard</code> file.</p>
<p>The UI will be a lot like our broadcaster app, so we just repeat all the steps. But instead of creating a &quot;Start&quot; button for our stream, we create a button with the title &quot;Play&quot; which will play back our stream. The other steps are identical. If you have trouble, please see the section <a href="#broadcast_view">Broadcast View</a> in the broadcaster part.  The result should look something like this:</p>
<h3><a class="anchor" aria-hidden="true" id="connection-to-viewcontroller-1"></a><a href="#connection-to-viewcontroller-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Connection to ViewController</h3>
<p>Just like in the broadcaster example, we create outlets for our view and our button to the ViewController. If you have trouble with these steps, please see the <a href="#connection_to_viewcontroller">section from the broadcaster part</a>.</p>
<p>We also create an action and name it <code>togglePlayback</code>. The result looks like this:</p>
<h3><a class="anchor" aria-hidden="true" id="importing-the-sdks-1"></a><a href="#importing-the-sdks-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Importing the SDKs</h3>
<p>Just like in our player app, we need to import the nanoStream SDK. If you have trouble with any of the following steps, please see the more <a href="#importing_the_sdks">detailed guide in the broadcaster section</a>.</p>
<p>For the player app, you need a little bit more than for the broadcaster, but not much. You need the files <code>Bintu.framework</code>, <code>libnanostreamAVC.a</code>, <code>nanostreamAVC.h</code>, <code>nanostreamAVCExtendedCaptureSession.h</code> and <code>nanostreamAVCRtmpSourceCaptureSession.h</code>. Drag all of them into your project in the Navigator on the left side. Here as well, check &quot;Copy items if needed&quot; for all of them.</p>
<p>Your project will probably look something like this:</p>
<p>Again as well, remove <code>Bintu.framework</code> from the &quot;Linked Frameworks&quot; section, because we will add it soon. Drag <code>Bintu.framework</code> from the left side into the &quot;Embedded Binaries&quot; section. Now it should be in the &quot;Linked Frameworks&quot; section again.</p>
<p>You can now build and run the project on your device. You should see the preview view and your &quot;Play&quot; button.</p>
<h3><a class="anchor" aria-hidden="true" id="setting-up-nanostream-sdk-1"></a><a href="#setting-up-nanostream-sdk-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setting up nanoStream SDK</h3>
<p>Again, you need to add the dependencies for nanoStream SDK. Please refer to this <a href="#setting_up_nanostream_sdk">guide</a> for instructions.</p>
<p>Once you have your dependencies in place, your &quot;Linked Frameworks&quot; section should look like this:</p>
<p>Now we can start coding. Enter your <code>ViewController.m</code> file. It will look something like this:</p>
<pre><code class="hljs"><span class="hljs-comment">//</span>
<span class="hljs-comment">//  ViewController.m</span>
<span class="hljs-comment">//  PlayingExample</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  Created by nanocosmos on 19.02.16.</span>
<span class="hljs-comment">//  Copyright © 2016 exampleorganisation. All rights reserved.</span>
<span class="hljs-comment">//</span>

<span class="hljs-meta">#import <span class="hljs-meta-string">"ViewController.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIView</span> *preview;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIButton</span> *playButton;

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span>

- (<span class="hljs-keyword">void</span>)viewDidLoad {
    [<span class="hljs-keyword">super</span> viewDidLoad];
    <span class="hljs-comment">// Do any additional setup after loading the view, typically from a nib.</span>
}

- (<span class="hljs-keyword">void</span>)didReceiveMemoryWarning {
    [<span class="hljs-keyword">super</span> didReceiveMemoryWarning];
    <span class="hljs-comment">// Dispose of any resources that can be recreated.</span>
}
- (<span class="hljs-keyword">IBAction</span>)togglePlayback:(<span class="hljs-keyword">id</span>)sender {
}

<span class="hljs-keyword">@end</span>
</code></pre>
<p>Now we can setup our rtmp player. Below <code>#import ViewController.h</code>, import our rtmp player header:</p>
<pre><code class="hljs">#<span class="hljs-keyword">import</span> <span class="hljs-string">"nanostreamAVCRtmpSourceCaptureSession.h"</span>
</code></pre>
<p>Add a property for the player below <code>@property (weak, nonatomic) IBOutlet UIButton *playButton;</code>:</p>
<pre><code class="hljs">@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>(strong) RtmpSourceCaptureSession *player;
</code></pre>
<p>After the <code>viewDidLoad</code> method, add the following lines which will create an instance of our player. Replace the license with you real license:</p>
<pre><code class="hljs">- (<span class="hljs-keyword">void</span>)<span class="hljs-string">viewDidAppear:</span>(BOOL)animated
{
    <span class="hljs-comment">// construct an instance of the player and give it our preview</span>
    self.player = [[RtmpSourceCaptureSession alloc] <span class="hljs-string">initWithPreview:</span>self.preview <span class="hljs-string">andStatusListener:</span>nil <span class="hljs-string">andLogLevel:</span>LogLevelMinimal];

    <span class="hljs-comment">// set the license</span>
    [self.player <span class="hljs-string">setLicense:</span>@<span class="hljs-string">"&lt;your license here&gt;"</span>];
}
</code></pre>
<p>We will configure the player later.</p>
<h3><a class="anchor" aria-hidden="true" id="setting-up-the-connection-to-bintulive"></a><a href="#setting-up-the-connection-to-bintulive" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setting up the connection to bintu.live</h3>
<p>In this part we again connect to bintu.live, this time we do not want to create a new stream but we want to play an existing one. For this use case, we assume that the last stream that is currently live is our stream. The following code follows that logic. If you have multiple users using your account, this may not work correctly (it may play another user's stream).</p>
<p>Below <code>#import &quot;nanostreamAVCRtmpSourceCaptureSession.h&quot;</code>, import the bintu.live connector:</p>
<pre><code class="hljs"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Bintu/Bintu.h&gt;</span></span>
</code></pre>
<p>Add these properties below <code>@property (strong) RtmpSourceCaptureSession *player;</code>:</p>
<pre><code class="hljs">@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>(strong) NSString *streamURL;
@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>(strong) NSString *streamName;

@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>(strong) BNTAPIClient *client;
</code></pre>
<p>These will hold an instance of our API client and contain the stream information which we will use for playback.</p>
<p>Add these lines to the end of the <code>viewDidAppear</code> method (replace <code>&lt;your apikey here&gt;</code> with your real API key.</p>
<pre><code class="hljs">// <span class="hljs-keyword">create</span> bintu api <span class="hljs-keyword">client</span> <span class="hljs-keyword">with</span> apikey
self.client = [[BNTAPIClient alloc] initWithAPIKey:@<span class="hljs-string">"&lt;your apikey here&gt;"</span>];
</code></pre>
<p>You are now ready to query your streams from bintu.live. To do this, fill out the <code>togglePlayback</code> method:</p>
<pre><code class="hljs">- (<span class="hljs-keyword">IBAction</span>)togglePlayback:(<span class="hljs-keyword">id</span>)sender {
    <span class="hljs-comment">// get all streams from our account</span>
    [<span class="hljs-keyword">self</span>.client getStreamsWithCompletion:^(<span class="hljs-built_in">NSArray</span> *streams, <span class="hljs-built_in">NSError</span> *err) {

        <span class="hljs-comment">// check for errors</span>
        <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"There was an error while receiving the streams: %@"</span>, err);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// the last stream in stream is the one that was created last</span>
        <span class="hljs-comment">// therefore we go through the array in reverse</span>
        <span class="hljs-keyword">for</span> (BNTStreamInfo *stream <span class="hljs-keyword">in</span> [streams reverseObjectEnumerator]) {

            <span class="hljs-comment">// check if this particular stream is live</span>
            <span class="hljs-keyword">if</span> (stream.state == BNTStreamStateLive) {

                <span class="hljs-comment">// we found a live one! this is the one we want to play</span>
                <span class="hljs-comment">// get rtmp playout information from it and store them</span>
                BNTRTMPPlayout *playout = [stream.rtmpPlayouts firstObject];
                <span class="hljs-keyword">self</span>.streamURL = playout.rtmpInfo.url;
                <span class="hljs-keyword">self</span>.streamName = playout.rtmpInfo.streamName;

                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"We found a stream. StreamURL %@, StreamName %@"</span>, <span class="hljs-keyword">self</span>.streamURL, <span class="hljs-keyword">self</span>.streamName);

                <span class="hljs-comment">// we found our stream, now we can exit the loop</span>
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.streamName || !<span class="hljs-keyword">self</span>.streamURL) {
            <span class="hljs-comment">// we found no live stream. log an error</span>
            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"There is no stream that is currently live."</span>);
            <span class="hljs-keyword">return</span>;
        }
    }];
}
</code></pre>
<p>This code will get all streams from bintu. These will be in chronological order, meaning the first stream in the list is the first stream that was created. We want to find the last stream that is live, so we traverse through the streams in reverse order. The first stream that we find that is live will be the latest live stream in chronological order. We store the information we get about that stream because we need them for playback later.</p>
<p>If no stream can be found that is live, we log an error to the console.</p>
<p>If you run your app and tap the play button, after a short while you should see something logged to the console. Either there was an error or you will get a stream. If this first test was successful, we can continue. If there was an error logged, please check your API key and your account. The error message should tell you something about the error. If not, contact us.</p>
<h3><a class="anchor" aria-hidden="true" id="play-the-stream-already"></a><a href="#play-the-stream-already" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Play the stream already!</h3>
<p>If the test was successful, we can now really play the stream that we found. We need to take our streamURL and streamName and put it into our nanoStream Player. The following code achieves this. Below</p>
<pre><code class="hljs">    if (!self.streamName || !self.streamURL) {
        // we found no live stream. log an error
        NSLog(@&quot;There is no stream that is currently live.&quot;);
        return;
    }
</code></pre>
<p>add this code:</p>
<pre><code class="hljs">// set our configuration
self.player.url = self.streamURL;
self.player.streamId = self.streamName;

// start playback
[self.player start];

// this callback is called asynchronously on a background thread/queue.
// UI updates should happen on the main queue, therefore switch to it
dispatch_async(dispatch_get_main_queue(), ^{

    // change the button title so we know we are playing
    [self.playButton setTitle:@&quot;Stop&quot; forState:UIControlStateNormal];
});
</code></pre>
<p>You can now run the app. If you have another device with the broadcaster app, start a stream there. Now tap the &quot;Play&quot; button in your app. After a while you should see that playback is starting and video should be displayed. Your &quot;Play&quot; button should change its title to &quot;Stop&quot;. If this does not happen, check your console log and check the previous steps.</p>
<p>We may want to stop playback before the stream has ended. For this, we can use the <code>-stop</code> method of our <code>RTMPSourceCaptureSession</code>. Checking if we are currently playing back a stream can be done via <code>-isPlaying</code>.</p>
<p>Now wrap the contents of the <code>-togglePlayback:</code> method with this check:</p>
<pre><code class="hljs">// check if we are playing already
if ([self.player isPlaying]) {

    // we are already playing. we want to stop now
    [self.player stop];

    // the player will stop, we now update the button title again
    dispatch_async(dispatch_get_main_queue(), ^{
        [self.playButton setTitle:@&quot;Play&quot; forState:UIControlStateNormal];
    });
} else {

    // we are not playing, we want to start playback

    // our previous code goes here
}
</code></pre>
<p>We are finished with the player. Our complete <code>-togglePlayback:</code> should look like this:</p>
<pre><code class="hljs">- (<span class="hljs-keyword">IBAction</span>)togglePlayback:(<span class="hljs-keyword">id</span>)sender {

    <span class="hljs-comment">// check if we are playing already</span>
    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.player isPlaying]) {

        <span class="hljs-comment">// we are already playing. we want to stop now</span>
        [<span class="hljs-keyword">self</span>.player stop];

        <span class="hljs-comment">// the player will stop, we now update the button title again</span>
        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            [<span class="hljs-keyword">self</span>.playButton setTitle:<span class="hljs-string">@"Play"</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];
        });
    } <span class="hljs-keyword">else</span> {

        <span class="hljs-comment">// we are not playing, we want to start playback</span>

        <span class="hljs-comment">// get all streams from our account</span>
        [<span class="hljs-keyword">self</span>.client getStreamsWithCompletion:^(<span class="hljs-built_in">NSArray</span> *streams, <span class="hljs-built_in">NSError</span> *err) {

            <span class="hljs-comment">// check for errors</span>
            <span class="hljs-keyword">if</span> (err) {
                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"There was an error while receiving the streams: %@"</span>, err);
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-comment">// the last stream in stream is the one that was created last</span>
            <span class="hljs-comment">// therefore we go through the array in reverse</span>
            <span class="hljs-keyword">for</span> (BNTStreamInfo *stream <span class="hljs-keyword">in</span> [streams reverseObjectEnumerator]) {

                <span class="hljs-comment">// check if this particular stream is live</span>
                <span class="hljs-keyword">if</span> (stream.state == BNTStreamStateLive) {

                    <span class="hljs-comment">// we found a live one! this is the one we want to play</span>
                    <span class="hljs-comment">// get rtmp playout information from it and store them</span>
                    BNTRTMPPlayout *playout = [stream.rtmpPlayouts firstObject];
                    <span class="hljs-keyword">self</span>.streamURL = playout.rtmpInfo.url;
                    <span class="hljs-keyword">self</span>.streamName = playout.rtmpInfo.streamName;

                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"We found a stream. StreamURL %@, StreamName %@"</span>, <span class="hljs-keyword">self</span>.streamURL, <span class="hljs-keyword">self</span>.streamName);

                    <span class="hljs-comment">// we found our stream, now we can exit the loop</span>
                    <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.streamName || !<span class="hljs-keyword">self</span>.streamURL) {
                <span class="hljs-comment">// we found no live stream. log an error</span>
                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"There is no stream that is currently live."</span>);
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-comment">// set our configuration</span>
            <span class="hljs-keyword">self</span>.player.url = <span class="hljs-keyword">self</span>.streamURL;
            <span class="hljs-keyword">self</span>.player.streamId = <span class="hljs-keyword">self</span>.streamName;

            <span class="hljs-comment">// start playback</span>
            [<span class="hljs-keyword">self</span>.player start];

            <span class="hljs-comment">// this callback is called asynchronously on a background thread/queue.</span>
            <span class="hljs-comment">// UI updates should happen on the main queue, therefore switch to it</span>
            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{

                <span class="hljs-comment">// change the button title so we know we are playing</span>
                [<span class="hljs-keyword">self</span>.playButton setTitle:<span class="hljs-string">@"Stop"</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];
            });
        }];
    }
}
</code></pre>
<p>You can find the complete player sample project in the SDK-folder, at <code>samples/SimplePlayer</code>. That sample also includes additional error handling and error surfacing, which has been omitted from this guide for brevity.</p>
<h2><a class="anchor" aria-hidden="true" id="end-to-end-goodness"></a><a href="#end-to-end-goodness" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>End-To-End Goodness</h2>
<p>You can now use both apps together if you have two devices to test on. Load the broadcaster app on one device and the player app on another one.</p>
<p>Start a stream in the broadcaster app. It should look something like this:</p>
<p>Now start the player app on the other device and press &quot;Play&quot;. It should find your stream from the other device and start playing it. Please allow a little time for the playback to begin. It should then look something like this:</p>
<p>Congratulations! You now have built your own live streaming app, end-to-end with nanoStream and bintu.live!</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 1/29/2021</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/nanostream/ios/nanostream_ios_quick_start"><span class="arrow-prev">← </span><span>Developer Quickstart</span></a><a class="docs-next button" href="/docs/nanostream/ios/nanostream_ios_sdk"><span class="function-name-prevnext">SDK for iOS</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#overview">Overview</a></li><li><a href="#prerequisites">Prerequisites</a></li><li><a href="#live-video-encoder-broadcast-app">Live Video Encoder (broadcast) app</a><ul class="toc-headings"><li><a href="#setup">Setup</a></li><li><a href="#broadcast-view">Broadcast View</a></li><li><a href="#connection-to-viewcontroller">Connection to ViewController</a></li><li><a href="#importing-the-sdks">Importing the SDKs</a></li><li><a href="#setting-up-nanostream-sdk">Setting up nanoStream SDK</a></li><li><a href="#setting-up-the-bintulive-connection">Setting up the bintu.live connection</a></li><li><a href="#putting-it-together">Putting it together</a></li></ul></li><li><a href="#playing-app">Playing App</a><ul class="toc-headings"><li><a href="#setup-1">Setup</a></li><li><a href="#playing-view">Playing View</a></li><li><a href="#connection-to-viewcontroller-1">Connection to ViewController</a></li><li><a href="#importing-the-sdks-1">Importing the SDKs</a></li><li><a href="#setting-up-nanostream-sdk-1">Setting up nanoStream SDK</a></li><li><a href="#setting-up-the-connection-to-bintulive">Setting up the connection to bintu.live</a></li><li><a href="#play-the-stream-already">Play the stream already!</a></li></ul></li><li><a href="#end-to-end-goodness">End-To-End Goodness</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><div><h5>Contact</h5><a href="https://www.nanocosmos.de/">Homepage</a><a href="https://www.nanocosmos.de/contact">Contact</a><a href="https://www.nanocosmos.de/support">Support</a><a href="https://www.nanocosmos.de/terms">Legal Terms</a></div><div><h5>Products</h5><a href="https://www.nanocosmos.de/cloud">Nanostream Cloud with Bintu.Live</a><a href="https://www.nanocosmos.de/h5live">H5Live Low Latency HTML5-Player</a><a href="https://www.nanocosmos.de/webrtc">nanoStream Webcaster</a><a href="https://www.nanocosmos.de/#nanostream">Nanostream Apps and SDK</a></div><div><h5>More</h5><a href="https://www.nanocosmos.de/blog/">Blog</a><a href="https://twitter.com/nanovideo">Twitter</a><a href="https://www.facebook.com/nanocosmos.net/">Facebook</a><a href="https://www.linkedin.com/company/nanocosmos-gmbh">LinkedIn</a><a href="https://github.com/nanocosmos/docs">GitHub</a><a class="github-button" href="https://github.com/nanocosmos/docs" data-icon="octicon-star" data-count-href="/nanocosmos/docs/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://nanocosmos.de/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/img/footer_logo.png" alt="nanocosmos GmbH" width="170" height="45"/></a><section class="copyright">Copyright © 2021 nanocosmos GmbH - doc version Fri Jan 29 2021 00:51:30 GMT+0000 (Coordinated Universal Time)</section></footer></div></body></html>