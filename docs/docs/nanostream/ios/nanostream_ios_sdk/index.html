<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>nanoStream SDK for iOS · nanocosmos Documentation</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="The documentation is updated for nanoStream SDK v.4.10.0.0 and Xcode 11."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="nanoStream SDK for iOS · nanocosmos Documentation"/><meta property="og:type" content="website"/><meta property="og:url" content="https://docs.nanocosmos.de/"/><meta property="og:description" content="The documentation is updated for nanoStream SDK v.4.10.0.0 and Xcode 11."/><meta property="og:image" content="https://docs.nanocosmos.de/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://docs.nanocosmos.de/img/docusaurus.png"/><link rel="shortcut icon" href="/img/favicon_nano.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typesense-docsearch.js@latest/dist/cdn/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-552140-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/copy-button.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/copy-button.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/nanocosmos_header_logo.png" alt="nanocosmos Documentation"/><h2 class="headerTitleWithLogo">nanocosmos Documentation</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/cloud/cloud_overview" target="_self">nanoStream Cloud</a></li><li class=""><a href="/docs/nanoplayer/nanoplayer_introduction" target="_self">H5Live Player</a></li><li class=""><a href="/docs/webrtc/nanostream_webrtc_introduction" target="_self">nanoStream Webcaster</a></li><li class=""><a href="/docs/nanomeet/introduction" target="_self">nanoMeet</a></li><li class="siteNavGroupActive"><a href="/docs/nanostream/nanostream" target="_self">nanoStream Apps and SDKs</a></li><li class=""><a href="/docs/samples/samples" target="_self">Samples</a></li><li class=""><a href="/docs/faq/faq_streaming" target="_self">FAQ</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>iOS</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">nanoStream SDKs/Apps</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/nanostream/nanostream">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Android</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/nanostream/android/nanostream_android_getting_started">Getting started</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/android/nanostream_android_developer_manual_playback">Playback</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/android/nanostream_android_developer_manual_streaming">Streaming Media</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/android/nanostream_android_developer_manual_sample">Sample</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">iOS</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/nanostream/ios/nanostream_ios_quick_start">Developer Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/ios/nanostream-ios-step-by-step">Getting started</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/nanostream/ios/nanostream_ios_sdk">SDK for iOS</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/ios/bintu_ios_sdk">bintu.live client SDK</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/ios/bintu_ios_sample">iOS Streaming App in 5 Minutes</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/ios/nanostream_ios_license_deployment">License Deployment Information</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Windows</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_windows_binaries">Binary Modules for Windows</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_windows_developer_manual">Developer Manual</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_windows_language_integration">nanoStream Windows Language Integration</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_windows_license_help">Setting the license</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_windows_networkwriter">RTMP Network Renderer &amp; Writer</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/windows/nanostream_encoder_plugin_api">Encoder Plugin API</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">DirectShow</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/nanostream_directshow_h264">H264</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/nanostream_directshow_rtmp">RTMP</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/directshow_rtmp_writer">RTMP Writer</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/nanostream_directshow_rtsp">RTSP</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/nanostream_directshow_udp_streaming">UDP/TS Streaming</a></li><li class="navListItem"><a class="navItem" href="/docs/nanostream/directshow/nanostream_directshow_video_filter">Video Filter</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/nanocosmos/docs/tree/master/docs/nanostream/ios/nanostream_ios_sdk.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">nanoStream SDK for iOS</h1></header><article><div><span><p>The documentation is updated for nanoStream SDK v.4.10.0.0 and Xcode 11.</p>
<h2><a class="anchor" aria-hidden="true" id="purpose"></a><a href="#purpose" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Purpose</h2>
<p>This documentation is about the nanoStream Live Video Streaming SDK for iOS and can be used by software developers to integrate nanoStream Live Video Encoding into custom apps.</p>
<h2><a class="anchor" aria-hidden="true" id="requirements"></a><a href="#requirements" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Requirements</h2>
<ul>
<li>Recommended:
<ul>
<li>Apple Mac with macOS 10.15 and Xcode 11</li>
<li>Apple iPhone/iPad with iOS 13</li>
</ul></li>
<li>Minimal:
<ul>
<li>Apple Mac with OS X 10.9 or higher and Xcode 6 or higher</li>
<li>Apple iPhone/iPad with iOS 8 or higher</li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="getting-started"></a><a href="#getting-started" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting Started</h2>
<h3><a class="anchor" aria-hidden="true" id="preparation"></a><a href="#preparation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preparation</h3>
<p>Add the library <strong><code>libnanostreamAVC.a</code></strong> as a dependency (Link Binary With Libraries) to your project.</p>
<p>Further required dependencies:</p>
<ul>
<li><code>libc++.tbd</code></li>
<li><code>Accelerate.framework</code></li>
<li><code>SystemConfiguration.framework</code></li>
<li><code>VideoToolbox.framework</code> (link as Optional, not as Required)</li>
<li><code>AudioToolbox.framework</code></li>
</ul>
<p>The old nanoStream SDK and Xcode versions may additionaly require:</p>
<ul>
<li><code>libc++.dylib</code> (instead of <code>libc++.tbd</code>)</li>
<li><code>libstdc++.dylib</code></li>
<li><code>AVFoundation.framework</code></li>
<li><code>CoreGraphics.framework</code></li>
<li><code>CoreMedia.framework</code></li>
<li><code>CoreVideo.framework</code></li>
<li><code>Foundation.framework</code></li>
</ul>
<p>Include the header <code>libnanostreamAVC.h</code> in your source code.</p>
<h3><a class="anchor" aria-hidden="true" id="check-library-version"></a><a href="#check-library-version" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Check library version</h3>
<pre><code class="hljs css language-objc"><span class="hljs-keyword">int</span> version = [nanostreamAVC getVersion];
<span class="hljs-keyword">if</span> (version != NANOSTREAM_AVC_VERSION) {
    <span class="hljs-comment">// Handle header and library version mismatch</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="initialize-the-library-for-broadcasting"></a><a href="#initialize-the-library-for-broadcasting" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Initialize the library for broadcasting</h3>
<p>For a complete running sample, see LiveEncoder and LiveStream apps included in the SDK package.</p>
<p>Implement the interface <code>nanostreamEventListener</code> in your class:</p>
<pre><code class="hljs css language-objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SampleLiveViewController</span> : <span class="hljs-title">UIViewController</span> &lt;<span class="hljs-title">nanostreamEventListener</span>&gt;</span>

...

<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) nanostreamAVC *nAVC;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIView</span> *previewView;

...

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SampleLiveViewController</span></span>

...

- (<span class="hljs-keyword">void</span>)nanostreamEventHandlerWithType:(nanostreamEvent)type andLevel:(<span class="hljs-keyword">int</span>)level andDescription:(<span class="hljs-built_in">NSString</span> *)description {
    <span class="hljs-keyword">switch</span> (type) {
            <span class="hljs-keyword">case</span> StreamStarted:
                  <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> StreamStopped:
                  <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> StreamError:
                  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"nanostreamEventHandlerWithType:StreamError: %@"</span>, description);
                  <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> StreamErrorConnect:
                  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"nanostreamEventHandlerWithType:StreamErrorConnect: %@"</span>, description);
                  <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> StreamConnectionStatus:
                  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"nanostreamEventHandlerWithType:RtmpConnectionStatus: %@"</span>, description);
                  <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> StreamSettingCropModeNotSupported:
                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"nanostreamEventHandlerWithType:StreamSettingCropModeNotSupported: %@"</span>, description);
                      <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> StreamSettingLocalRecordingCropModeNotSupported:
                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"nanostreamEventHandlerWithType:StreamSettingLocalRecordingCropModeNotSupported: %@"</span>, description);
                      <span class="hljs-keyword">break</span>;        
            <span class="hljs-keyword">case</span> GeneralError:
                  <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                  <span class="hljs-keyword">break</span>;
      }
}

...

<span class="hljs-keyword">@end</span>
</code></pre>
<p>Configure the settings object for the library:</p>
<pre><code class="hljs css language-objc">nanostreamAVCSettings *nAVCSettings = [[nanostreamAVCSettings alloc] init];

<span class="hljs-comment">// Set the RTMP URL, you want to stream to</span>
[nAVCSettings setUrl:<span class="hljs-string">@"rtmp://localhost/live"</span>];
[nAVCSettings setStreamId:<span class="hljs-string">@"myStream"</span>];

<span class="hljs-comment">// Set the video settings</span>
[nAVCSettings setVideoResolution:Resolution640x480];
[nAVCSettings setVideoBitrate:<span class="hljs-number">512</span>];
[nAVCSettings setKeyFramerate:<span class="hljs-number">60</span>];
[nAVCSettings setOrientation:<span class="hljs-built_in">AVCaptureVideoOrientationLandscapeRight</span>];
[nAVCSettings setCropMode:NoCrop];
[nAVCSettings setFramerate:<span class="hljs-number">30</span>];
[nAVCSettings setH264Level:Baseline30];

<span class="hljs-comment">// Set the audio settings</span>
[nAVCSettings setInitialVolume:<span class="hljs-number">1.0</span>];
[nAVCSettings setAudioMonoStereo:Stereo];
[nAVCSettings setAudioSamplerate:<span class="hljs-number">44100.0</span>f];
</code></pre>
<p>Then the library itself can be initialized:</p>
<pre><code class="hljs css language-objc"><span class="hljs-comment">// nAVC is a property of the controller class in this example</span>
<span class="hljs-keyword">self</span>.nAVC = [[nanostreamAVC alloc] initWithSettings:nAVCSettings
                                      eventListener:<span class="hljs-keyword">self</span>];

<span class="hljs-comment">// Set the license key (required for streaming)</span>
[<span class="hljs-keyword">self</span>.nAVC setLicense:<span class="hljs-string">@"nlic:1.2:LiveEnc:1.1:LvApp=1.....288"</span>];

<span class="hljs-comment">// Implement the nanostreamEventListener protocol method </span>
<span class="hljs-comment">// to display a preview in the previewView</span>
- (<span class="hljs-keyword">void</span>)didUpdatePreviewLayer:(<span class="hljs-built_in">CALayer</span>*)layer {

    <span class="hljs-comment">// UI View is modified, main queue required</span>
    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.previewView.layer.sublayers.count &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">self</span>.previewView.layer.sublayers = <span class="hljs-literal">nil</span>;
        }
        layer.bounds = <span class="hljs-built_in">CGRectZero</span>;
        [layer setFrame:<span class="hljs-keyword">self</span>.previewView.bounds];
        [(<span class="hljs-built_in">AVCaptureVideoPreviewLayer</span>*)layer setVideoGravity:<span class="hljs-built_in">AVLayerVideoGravityResizeAspectFill</span>];
        [<span class="hljs-keyword">self</span>.previewView.layer addSublayer:layer];
    });
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="start-a-stream"></a><a href="#start-a-stream" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Start a stream</h3>
<pre><code class="hljs css language-objc"><span class="hljs-comment">// Start broadcast asynchronously with completion handler</span>
[<span class="hljs-keyword">self</span>.nAVC start:^(<span class="hljs-built_in">NSXError</span> error) {
    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        <span class="hljs-keyword">if</span> (error == <span class="hljs-built_in">NSXErrorNone</span>) {
            <span class="hljs-comment">// Handle succesful stream start</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Handle failure</span>
        }
    });
}];
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="stop-a-running-stream"></a><a href="#stop-a-running-stream" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stop a running stream</h3>
<p>If the parameter <code>blocking</code> of the stop method is set to <code>YES</code>, all the remaining data (to this moment) will be sent before stopping the stream.
If set to <code>NO</code>, the stream will stop immediately, discarding the remaining data.</p>
<pre><code class="hljs css language-objc">    <span class="hljs-comment">// Stop broadcast asynchronously with completion handler</span>
    [<span class="hljs-keyword">self</span>.nAVC stop:<span class="hljs-literal">YES</span> withCompletion:^{
      <span class="hljs-comment">// Use the main queue to update UI</span>
      <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        <span class="hljs-comment">// Handle stream stop</span>
      }
    }];
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="live-playback"></a><a href="#live-playback" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Live Playback</h2>
<p>nanoStream supports live playback from <code>RTMP</code> sources.
For a complete running sample, see LivePlayer and LiveStream apps included in the SDK package.</p>
<h3><a class="anchor" aria-hidden="true" id="initialize-the-library-for-playback"></a><a href="#initialize-the-library-for-playback" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Initialize the library for playback</h3>
<pre><code class="hljs css language-objc"><span class="hljs-keyword">self</span>.session = [[RtmpSourceCaptureSession alloc] initWithLogLevel:LogLevelMinimal];
<span class="hljs-keyword">self</span>.session.delegate = <span class="hljs-keyword">self</span>;
    
[<span class="hljs-keyword">self</span>.session setLicense:myLicenseKey];
    
[<span class="hljs-keyword">self</span>.session setUrl:<span class="hljs-keyword">self</span>.rtmpServerURL];
[<span class="hljs-keyword">self</span>.session setStreamId:<span class="hljs-keyword">self</span>.rtmpStreamName];

...

<span class="hljs-comment">// Implement the RtmpSourceCaptureSessionStatusListener protocol method </span>
<span class="hljs-comment">// to display a playback in the playerView</span>
- (<span class="hljs-keyword">void</span>)didUpdateDisplayLayer:(<span class="hljs-built_in">CALayer</span> *)layer {

    <span class="hljs-comment">// UI View is modified, main queue required</span>
    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.playerView.layer.sublayers == <span class="hljs-literal">nil</span>) {
            [<span class="hljs-keyword">self</span>.playerView.layer addSublayer:layer];
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Replace a current display layer with the new one</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">CALayer</span>* subLayer <span class="hljs-keyword">in</span> [<span class="hljs-keyword">self</span>.playerView.layer sublayers]) {
                <span class="hljs-keyword">if</span> ([subLayer isKindOfClass:<span class="hljs-built_in">AVSampleBufferDisplayLayer</span>.class]) {
                    [<span class="hljs-keyword">self</span>.playerView.layer replaceSublayer:subLayer with:layer];
                }
            }
        }

        layer.bounds = <span class="hljs-built_in">CGRectZero</span>;
        [layer setFrame:<span class="hljs-keyword">self</span>.playerView.bounds];
        [(<span class="hljs-built_in">AVSampleBufferDisplayLayer</span> *)layer setVideoGravity:<span class="hljs-built_in">AVLayerVideoGravityResizeAspect</span>];

        [<span class="hljs-keyword">self</span>.session didUpdateDisplayLayerFinished];
    });
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="start-playback"></a><a href="#start-playback" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Start playback</h3>
<pre><code class="hljs css language-objc">[<span class="hljs-keyword">self</span>.session start:^{
    <span class="hljs-comment">// Hanlde playback start</span>
}];
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="advanced-settingsusage"></a><a href="#advanced-settingsusage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advanced Settings/Usage</h2>
<h3><a class="anchor" aria-hidden="true" id="meaning-of-events-and-errors-nanostreamevent"></a><a href="#meaning-of-events-and-errors-nanostreamevent" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Meaning of Events and Errors (nanostreamEvent)</h3>
<table>
<thead>
<tr><th>Event</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><strong><code>StreamStarted/StreamStopped</code></strong></td><td>notification that a stream was successfully started/stopped</td></tr>
<tr><td><strong><code>StreamConnectionStatus</code></strong></td><td>indicates the connection status: connected, disconnected or reconnecting</td></tr>
</tbody>
</table>
<p><br></p>
<table>
<thead>
<tr><th>Error</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><strong><code>StreamSettingCropModeNotSupported</code></strong></td><td>a larger input resolution is required for the crop mode</td></tr>
<tr><td><strong><code>StreamSettingLocalRecordingCropModeNotSupported</code></strong></td><td>a larger input resolution is required for the local recording crop mode</td></tr>
<tr><td><strong><code>StreamErrorConnect</code></strong></td><td>the connection to the server could not be established, server might no be reachable or there are network problems</td></tr>
<tr><td><strong><code>StreamErrorConnectSSL</code></strong></td><td>the connection process failed when trying to setup SSL, maybe the server certificates could not be verified</td></tr>
<tr><td><strong><code>StreamError</code></strong></td><td>an error occurred while initializing the stream, or during the stream, used license might be invalid or expired</td></tr>
<tr><td><strong><code>GeneralError</code></strong></td><td>a general error</td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="switch-camera"></a><a href="#switch-camera" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Switch Camera</h3>
<p>The camera (front/back) can be switched during preview and broadcast, with the method:</p>
<pre><code class="hljs css language-objc">- (<span class="hljs-keyword">bool</span>)useFrontCamera:(<span class="hljs-keyword">bool</span>)value;   <span class="hljs-comment">// Returns true if switch was successful</span>
</code></pre>
<p>It is also possible to select the desired camera directly, when initializing the library, by using the property <code>frontCamera</code> of the <code>nanostreamAVCSettings</code> object:</p>
<h3><a class="anchor" aria-hidden="true" id="orientation"></a><a href="#orientation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Orientation</h3>
<p>The orientation of the stream can be set to portrait or landscape with the property <code>orientation</code> of the settings object.</p>
<p>As of version 4.4.0.6 the orientation can also be changed after the initialization with the property <code>orientation</code> of the <code>nanostreamAVC</code> object itself.</p>
<blockquote>
<p><strong>Important:</strong></p>
<p>The orientation change will only affect the stream, but not the preview. The orientation for the preview has to be managed on the application level. This can be achieved by using e.g. <a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform"><code>CGAffineTransformMakeRotation</code> </a>.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="stream-type"></a><a href="#stream-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stream Type</h3>
<p>The SDK supports different streaming modes:</p>
<ul>
<li>Video and Audio</li>
<li>Video only</li>
<li>Audio only</li>
</ul>
<p>You can configure the mode with the property <code>streamType</code> of the settings object.</p>
<h3><a class="anchor" aria-hidden="true" id="zoom"></a><a href="#zoom" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Zoom</h3>
<p>The following properties and methods are available for zooming:</p>
<pre><code class="hljs css language-objc"><span class="hljs-comment">/**
 *  maxZoomFactor
 *
 *  Returns the maximum zoom factor that can be set on the current device.
 *  This includes the zoom via upscaling.
 *
 *  @return Maximum Zoom factor that can be set on the current device
 */</span>
- (<span class="hljs-built_in">CGFloat</span>)maxZoomFactor;
</code></pre>
<pre><code class="hljs css language-objc"><span class="hljs-comment">/**
 *  Newer devices can use an almost-optical zoom, using the bigger sensor sizes.
 *  Setting the zoom factor to a value smaller than this value uses a lossless
 *  zoom.
 *
 *  @return Max Zoom factor that can be set without using upscaling.
 */</span>
- (<span class="hljs-built_in">CGFloat</span>)maxZoomFactorWithoutUpscaling;
</code></pre>
<pre><code class="hljs css language-objc"><span class="hljs-comment">/**
 *  Sets the zoom factor for the camera. Available from iOS 7.1 onwards.
 *
 *  @param factor Double between 1.0 and maxZoomFactor. Will be set for the 
 *  current capture device. Will be reset when the device changes (camera rotation)
 *  Zoom factor will be applied with a ramp function, which results in a smooth
 *  transition to the given factor. If a value smaller than 
 *  maxZoomFactorWithoutUpscaling is set, the zoom will be lossless.
 *
 *  @return YES if zoom was set. NO if not.
 */</span>
- (<span class="hljs-built_in">BOOL</span>)setZoomFactor:(<span class="hljs-built_in">CGFloat</span>)factor;
</code></pre>
<p>Zooming is also demonstrated in the sample project <code>LiveStream</code>, included in the SDK package.</p>
<h3><a class="anchor" aria-hidden="true" id="server-authentication"></a><a href="#server-authentication" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Server Authentication</h3>
<p>In case authentication is required, the credentials can be set with the method:</p>
<pre><code class="hljs css language-objc">- (<span class="hljs-keyword">void</span>)setAuthentication:(<span class="hljs-built_in">NSString</span>*)user withPassword:(<span class="hljs-built_in">NSString</span>*)password;
</code></pre>
<p>The method has to be invoked before a stream is started.</p>
<p>For example:</p>
<pre><code class="hljs css language-objc"><span class="hljs-comment">// Set up nAVC object</span>

...

[nAVC setAuthentication:<span class="hljs-string">@"MyUser"</span> withPassword:<span class="hljs-string">@"MyPassword"</span>];

...

<span class="hljs-comment">// Start the stream</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="local-recording"></a><a href="#local-recording" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local Recording</h3>
<p>It is possible to make a local copy of the stream, on the iOS device.
This is an extra feature and needs to be unlocked by the license - the license should contain the string <code>MP4=2</code>.</p>
<pre><code class="hljs css language-objc"><span class="hljs-built_in">NSString</span> *homeDirectory = [<span class="hljs-built_in">NSHomeDirectory</span>() stringByAppendingPathComponent:<span class="hljs-string">@"Documents"</span>];
<span class="hljs-built_in">NSDateFormatter</span> *dateFormatter = [[<span class="hljs-built_in">NSDateFormatter</span> alloc] init];
[dateFormatter setDateFormat:<span class="hljs-string">@"yyyy-MM-dd_HH-mm-ss"</span>];
<span class="hljs-built_in">NSString</span> *locStr = [homeDirectory stringByAppendingPathComponent:[[dateFormatter stringFromDate:[<span class="hljs-built_in">NSDate</span> date]] stringByAppendingString:<span class="hljs-string">@".mp4"</span>]];

[nAVCSettings setLocalRecordingMode:<span class="hljs-built_in">AVCRecordingModeDoubleAtLeastOneMbit</span>];
[nAVCSettings setLocalRecordingPath:locStr];
</code></pre>
<p>The following recording modes are available:</p>
<ul>
<li><strong><code>AVCRecordingModeStartBitrate</code></strong>: uses the video bitrate set with <code>nanostreamAVCSettings</code></li>
<li><strong><code>AVCRecordingModeDoubleAtLeastOneMbit</code></strong>: uses double the video bitrate, but at least <code>1Mbps</code></li>
<li><strong><code>AVCRecordingMode720p2Mbit</code></strong>: independent of the set video bitrate, always uses <code>2Mbps</code> and a resolution of <code>1280x720</code></li>
<li><strong><code>AVCRecordingMode720p4Mbit</code></strong>: independent of the set video bitrate, always uses <code>4Mbps</code> and a resolution of <code>1280x720</code></li>
<li><strong><code>AVCRecordingMode1080p4Mbit</code></strong>: independent of the set video bitrate, always uses <code>4Mbps</code> and a resolution of <code>1920x1080</code></li>
<li><strong><code>AVCRecordingMode1080p6Mbit</code></strong>: independent of the set video bitrate, always uses <code>6Mbps</code> and a resolution of <code>1920x1080</code></li>
<li><strong><code>AVCRecordingMode1080p8Mbit</code></strong>: independent of the set video bitrate, always uses <code>8Mbps</code> and a resolution of <code>1920x1080</code></li>
</ul>
<p>The bitrate for the recording remains constant during a stream. The adaptive bitrate mechanism only influences the bitrate for the stream, but not the bitrate for the recording.</p>
<p>The bitrate for the recording also depends on the video material. If there is a lot of movement in the video the bitrate will be higher than for recordings with little to no movement.</p>
<h3><a class="anchor" aria-hidden="true" id="cropping"></a><a href="#cropping" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cropping</h3>
<p>Both, the stream and the local recording can be transformed to a different format than the input from the camera.</p>
<p>The following example shows how to crop the format to <code>16:9</code>.</p>
<pre><code class="hljs css language-objc"><span class="hljs-comment">// Set crop mode for the stream</span>
[nAVCSettings setCropMode:CropTo16By9];

<span class="hljs-comment">// Set crop mode for the local recording</span>
[nAVCSettings setLocalRecordingCropMode:CropTo16By9];
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="adaptive-bitrate"></a><a href="#adaptive-bitrate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adaptive Bitrate</h3>
<p>By using the Adaptive Bitrate Control (<em>ABC</em>) the stream will automatically adjust to changes of the bandwidth.</p>
<p>There are two modes available:</p>
<ul>
<li><p><strong><code>AdaptiveBitrateControlModeQualityDegrade</code></strong>: The video quality will be changed if the bandwidth changes. For instance, if not enough bandwidth is available, the video bitrate will be decreased, which in turn degrades the video quality.</p></li>
<li><p><strong><code>AdaptiveBitrateControlModeFrameDrop</code></strong>: Low bandwidth is compensated by decreasing the framerate (FPS), but maintaining the video qualtiy.</p></li>
</ul>
<p>Make sure to set the ABC settings before a stream is started.</p>
<pre><code class="hljs css language-objc">[<span class="hljs-keyword">self</span>.nAVC setAdaptiveBitrateControlMode:AdaptiveBitrateControlModeQualityDegrade];
        
AdaptiveBitrateControlSettings abr;
abr.minimumBitrate = <span class="hljs-number">100000</span>;  <span class="hljs-comment">// 100kb</span>
abr.minimumFramerate = <span class="hljs-number">15</span>;
abr.maxPercentBitrateChange = <span class="hljs-number">50</span>;  <span class="hljs-comment">// If the bitrate drops to less than 50% of the previous bitrate, all buffered data will be discarded</span>
    
[<span class="hljs-keyword">self</span>.nAVC setAdaptiveBitrateControlSettings:abr];
</code></pre>
<p>Possible properties:</p>
<table>
<thead>
<tr><th>property</th><th>default values</th><th>range of values</th><th>optional</th></tr>
</thead>
<tbody>
<tr><td><strong><code>minimumBitrate</code></strong></td><td>5000 (50 kb)</td><td>50000 - 10 000 000</td><td>YES</td></tr>
<tr><td><strong><code>minimumFramerate</code></strong></td><td>15 (fps)</td><td>5 - 60</td><td>YES</td></tr>
<tr><td><strong><code>maxPercentBitrateChange</code></strong></td><td>50 (%)</td><td>0 - 100</td><td>YES</td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="statistics-during-streaming"></a><a href="#statistics-during-streaming" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Statistics during streaming</h3>
<p>You can track the current bandwidth with the delegate method:</p>
<pre><code class="hljs css language-objc">- (<span class="hljs-keyword">void</span>)nanoStreamStatisticsHandlerWithOutputBitrate:(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)oBitrate
                                         andFillness:(<span class="hljs-keyword">double</span>)fillness
                              andCurrentVideoBitrate:(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)vBitrate
                            andCurrentVideoFramerate:(<span class="hljs-keyword">double</span>)vFramerate
</code></pre>
<p>This method will be invoked every second.</p>
<p>Meaning of the parameters:</p>
<ul>
<li><strong><code>oBitrate</code></strong>: the measured outgoing bitrate for the stream - this is an estimation and probably not 100% accurate</li>
<li><strong><code>fillness</code></strong>: the fillness, in percent, of the buffer used for outgoing packages</li>
<li><strong><code>vBitrate</code></strong>: the currently used bitrate for video</li>
<li><strong><code>vFramerate</code></strong>: the currently used framerate for video</li>
</ul>
<table>
<thead>
<tr><th style="text-align:left">property</th><th style="text-align:left">default values</th><th style="text-align:left">range of values</th><th style="text-align:left">optional</th></tr>
</thead>
<tbody>
<tr><td style="text-align:left"><strong><code>minimumBitrate</code></strong></td><td style="text-align:left">5000 (50 kb)</td><td style="text-align:left">50000 - 10 000 000</td><td style="text-align:left">YES</td></tr>
<tr><td style="text-align:left"><strong><code>minimumFramerate</code></strong></td><td style="text-align:left">15 (fps)</td><td style="text-align:left">5 - 60</td><td style="text-align:left">YES</td></tr>
<tr><td style="text-align:left"><strong><code>maxPercentBitrateChange</code></strong></td><td style="text-align:left">50 (%)</td><td style="text-align:left">0 - 100</td><td style="text-align:left">YES</td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="measuring-the-available-bandwidth"></a><a href="#measuring-the-available-bandwidth" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Measuring the available bandwidth</h3>
<p>For measuring the available bandwidth you can use the method <code>runBandwidthCheck</code>. After the check finished, the result can be used to set the bitrate for the <code>nanostreamAVC</code> object.</p>
<p>The check measures the bandwidth by running a test stream to the server.</p>
<pre><code class="hljs css language-objc"><span class="hljs-built_in">NSXBandwidthCheckSettings</span> *bwSettings = [[<span class="hljs-built_in">NSXBandwidthCheckSettings</span> alloc] init];

<span class="hljs-comment">// The URL settings are identical to the URL settings for the nanostreamAVCSettings</span>
<span class="hljs-comment">// for testing the bandwidth it is advised to use the same server you want to stream to</span>
<span class="hljs-comment">// you might want to use a stream id different from the stream id for the actual stream, </span>
<span class="hljs-comment">// to distinguish between a bandwidth check and a real stream</span>
bwSettings.url = <span class="hljs-string">@"rtmp://localhost/live"</span>;
bwSettings.streamId = <span class="hljs-string">@"bwcheck"</span>;

<span class="hljs-comment">// The maxium bitrate that should be tested - if this value is lower than the actual bandwidth, </span>
<span class="hljs-comment">// the result will be similar to the maximum bitrate</span>
bwSettings.maxBitrate = <span class="hljs-number">5000000</span>; <span class="hljs-comment">// 5Mb</span>
    
[<span class="hljs-keyword">self</span>.nAVC runBandwidthCheck:bwSettings withCompletionBlock:^(<span class="hljs-built_in">NSXBandwidthCheckResult</span> *measuredBandwidth) {
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"measuredBandwidth: avg=%i, median=%i, min=%i, max=%i, runTimeMs=%i"</span>, (<span class="hljs-keyword">int</span>)measuredBandwidth.avgBitrate, (<span class="hljs-keyword">int</span>)measuredBandwidth.medianBitrate, (<span class="hljs-keyword">int</span>)measuredBandwidth.minBitrate, (<span class="hljs-keyword">int</span>)measuredBandwidth.maxBitrate, (<span class="hljs-keyword">int</span>)measuredBandwidth.runTimeMs);
}];
</code></pre>
<p>The default run time is 10 seconds. The run time can be changed with the property <code>runTime</code>.
If the bandwidth check should be stopped before it finished on itself, the method <code>stopBandwidthCheck</code> can be used. This will force the bandwidth check to stop and return the result based on the collected information up to this point.</p>
<pre><code class="hljs css language-objc">[<span class="hljs-keyword">self</span>.nAVC stopBandwidthCheck]; <span class="hljs-comment">// Stop bandwidth check if still running</span>
</code></pre>
<p>The result of the bandwidth check can be used as bitrate setting for library object. At the moment it is not possible to change the video bitrate after the initialization of the library object, thus the object need to be re-initialized. (This will change in future releases.)</p>
<h3><a class="anchor" aria-hidden="true" id="snaphot-from-the-current-stream"></a><a href="#snaphot-from-the-current-stream" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Snaphot from the current stream</h3>
<p>To get a snaphot (image) of the current preview/stream, the method <code>grabStillImageWithCompletionBlock</code> can be used.</p>
<pre><code class="hljs css language-objc">[<span class="hljs-keyword">self</span>.nAVC grabStillImageWithCompletionBlock:^(<span class="hljs-built_in">UIImage</span> *image, <span class="hljs-built_in">NSError</span> *error) {
      <span class="hljs-comment">// Do something with the image</span>
}];
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="overlaywatermark"></a><a href="#overlaywatermark" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overlay/Watermark</h3>
<p>It is possible to use an overlay (image, text, or both) for a stream. Notice that the CPU usage will be increased slightly when an overlay is used.
This is an extra feature and needs to be unlocked by the license - the license should contain the string <code>OVL=1</code>.</p>
<p>The easiest way to use an overlay is to use the class <code>AVCFullImageOverlay</code>:</p>
<pre><code class="hljs css language-objc"><span class="hljs-built_in">UIImage</span> *overlayImg = [<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@"button"</span>];  <span class="hljs-comment">// Uses an image from the bundle resources, named "button"</span>
        
<span class="hljs-built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="hljs-built_in">CGSizeMake</span>(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>), <span class="hljs-literal">NO</span>, <span class="hljs-number">1.0</span>);  <span class="hljs-comment">// Assuming the video resolution is set to "Resolution640x480"</span>
[overlayImg drawInRect:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">240</span>, <span class="hljs-number">80</span>) blendMode:kCGBlendModeNormal alpha:<span class="hljs-number">0.5</span>];
<span class="hljs-built_in">UIFont</span> *font = [<span class="hljs-built_in">UIFont</span> boldSystemFontOfSize:<span class="hljs-number">20</span>];
[[<span class="hljs-built_in">UIColor</span> whiteColor] set];
<span class="hljs-built_in">NSString</span> *text = <span class="hljs-string">@"Watermark"</span>;
[text drawInRect:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>) withFont:font];
<span class="hljs-built_in">UIImage</span> *finalOverlayImage = <span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span>();
<span class="hljs-built_in">UIGraphicsEndImageContext</span>();
        
[<span class="hljs-keyword">self</span>.nAVC setOverlay:[[<span class="hljs-built_in">AVCFullImageOverlay</span> alloc] initWithImage:finalOverlayImage]];
</code></pre>
<p>Notice that the final output resolution can be different, if an option like cropping is used.
In this case it is better to implement your own overlay class, which is shown in the following example:</p>
<pre><code class="hljs css language-objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSXWatermark</span> () : <span class="hljs-title">NSObject</span> `&lt;​<span class="hljs-title">AVCOverlay</span>&gt;`​</span>
    
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>) <span class="hljs-built_in">AVCOverlayRawBuffer</span> buffer;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>) __attribute__((<span class="hljs-built_in">NSObject</span>)) <span class="hljs-built_in">CFDataRef</span> imageDataForBuffer;
    
<span class="hljs-keyword">@end</span>
    
    
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSXWatermark</span></span>
    
<span class="hljs-keyword">@synthesize</span> overlayBoundingRect;
<span class="hljs-keyword">@synthesize</span> imageSize;
    
    
- (<span class="hljs-built_in">AVCOverlayRawBuffer</span>)overlayImageWithStreamTime:(<span class="hljs-built_in">NSTimeInterval</span>)time {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.buffer.buffer == <span class="hljs-literal">NULL</span>) {
          <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-keyword">self</span> generateWatermarkWithSize:<span class="hljs-keyword">self</span>.imageSize inBoundingRect:<span class="hljs-keyword">self</span>.overlayBoundingRect];
          <span class="hljs-keyword">if</span> (image) {
              [<span class="hljs-keyword">self</span> setupBufferWithImage:image];
          }
      }
        
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.buffer;
}
    
- (<span class="hljs-built_in">UIImage</span> *)generateWatermarkWithSize:(<span class="hljs-built_in">CGSize</span>)size inBoundingRect:(<span class="hljs-built_in">CGRect</span>)boundingRect {
      <span class="hljs-built_in">UIImage</span> *overlayImage;
      <span class="hljs-built_in">CGFloat</span> padding = <span class="hljs-number">10.0</span>;
        
      <span class="hljs-comment">// Permanent Overlay</span>
      <span class="hljs-built_in">CGRect</span> permRealRect;
      <span class="hljs-built_in">UIImage</span> *permanentImage = <span class="hljs-keyword">self</span>.permanentOverlayImage;
      <span class="hljs-keyword">if</span> (permanentImage) {
          <span class="hljs-built_in">CGSize</span> overlaySize = permanentImage.size;
            
          <span class="hljs-built_in">CGFloat</span> height = size.height / <span class="hljs-number">3</span>;
          <span class="hljs-keyword">if</span> (overlaySize.height &gt; height) {
              overlaySize.width = height;
              overlaySize.height = height;
          }
            
          <span class="hljs-built_in">CGFloat</span> boundingMaxX = boundingRect.origin.x + boundingRect.size.width;
          <span class="hljs-built_in">CGFloat</span> boundingMaxY = boundingRect.origin.y + boundingRect.size.height;
            
            
          <span class="hljs-built_in">CGRect</span> permOverlayRect = <span class="hljs-built_in">CGRectMake</span>(boundingMaxX - overlaySize.width/<span class="hljs-number">2</span>, boundingMaxY - overlaySize.height/<span class="hljs-number">2</span>, overlaySize.width/<span class="hljs-number">2</span>, overlaySize.height/<span class="hljs-number">2</span>);
            
          permRealRect =  <span class="hljs-built_in">AVMakeRectWithAspectRatioInsideRect</span>(permanentImage.size, permOverlayRect);
            
          permRealRect.origin.y -= padding;
          permRealRect.origin.x -= padding;
      }
        
      <span class="hljs-built_in">UIGraphicsBeginImageContext</span>(size);
        
      <span class="hljs-keyword">if</span> (permanentImage) {
          [permanentImage drawInRect:permRealRect];
      }
        
      overlayImage = <span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span>();
        
      <span class="hljs-built_in">UIGraphicsEndImageContext</span>();
        
      <span class="hljs-keyword">return</span> overlayImage;
}
    
- (<span class="hljs-keyword">void</span>)setupBufferWithImage:(<span class="hljs-built_in">UIImage</span> *)image {
      <span class="hljs-built_in">CGImageRef</span> rawPic = [image <span class="hljs-built_in">CGImage</span>];
      <span class="hljs-built_in">CFDataRef</span> data = [<span class="hljs-built_in">NSXWatermark</span> copyDataFromUIImage:rawPic];
      <span class="hljs-built_in">AVCOverlayRawBuffer</span> buf = [<span class="hljs-built_in">NSXWatermark</span> makeBufferFromData:data andImage:rawPic];
        
      <span class="hljs-keyword">self</span>.buffer = buf;
      <span class="hljs-keyword">self</span>.imageDataForBuffer = data;
        
      <span class="hljs-built_in">CFRelease</span>(data);
}
    
+ (<span class="hljs-built_in">CFDataRef</span>)copyDataFromUIImage:(<span class="hljs-built_in">CGImageRef</span>)image {
      <span class="hljs-built_in">CGDataProviderRef</span> inProvider = <span class="hljs-built_in">CGImageGetDataProvider</span>(image);
      <span class="hljs-built_in">CFDataRef</span> inBitmapData = <span class="hljs-built_in">CGDataProviderCopyData</span>(inProvider);
      <span class="hljs-keyword">return</span> inBitmapData;
}
    
+ (<span class="hljs-built_in">AVCOverlayRawBuffer</span>)makeBufferFromData:(<span class="hljs-built_in">CFDataRef</span>)inBitmapData andImage:(<span class="hljs-built_in">CGImageRef</span>)rawPic {
      <span class="hljs-built_in">AVCOverlayRawBuffer</span> rawBuf;
        
      size_t inBitmapDataBytesPerRow = <span class="hljs-built_in">CGImageGetBytesPerRow</span>(rawPic);
        
      <span class="hljs-built_in">UInt8</span> *buffer = (<span class="hljs-built_in">UInt8</span>*)<span class="hljs-built_in">CFDataGetBytePtr</span>(inBitmapData);
        
      rawBuf.buffer = buffer;
      rawBuf.bytesPerRow = (<span class="hljs-keyword">int</span>)inBitmapDataBytesPerRow;
      rawBuf.bufferType = <span class="hljs-built_in">AVCOverlayBufferTypeBGRA</span>;
        eturn rawBuf;
}
    
<span class="hljs-keyword">@end</span>
</code></pre>
<p>If you want to use a dynamic overlay, e.g. a scoreboard, you can modify the above class (<code>NSXWatermark</code>) like so:</p>
<pre><code class="hljs css language-objc">...

<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *overlayURL; <span class="hljs-comment">// Needs to be set</span>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSDate</span> *date;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIImage</span> *watermarkHttpImage;

...

- (<span class="hljs-built_in">AVCOverlayRawBuffer</span>)overlayImageWithStreamTime:(<span class="hljs-built_in">NSTimeInterval</span>)time {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.date) {
        <span class="hljs-keyword">self</span>.date = [<span class="hljs-built_in">NSDate</span> date];
    }
    <span class="hljs-built_in">NSTimeInterval</span> timeInterval = time &lt;= <span class="hljs-number">0.6</span> ? <span class="hljs-number">0.6</span> : time;
    <span class="hljs-built_in">NSTimeInterval</span> passedTime = [[<span class="hljs-built_in">NSDate</span> date] timeIntervalSinceDate:<span class="hljs-keyword">self</span>.date];
    <span class="hljs-keyword">if</span> (passedTime &gt; timeInterval &amp;&amp; <span class="hljs-keyword">self</span>.overlayURL) {
        [<span class="hljs-keyword">self</span> loadHTTPImageAsync];
        <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-keyword">self</span> generateWatermarkWithSize:<span class="hljs-keyword">self</span>.imageSize inBoundingRect:<span class="hljs-keyword">self</span>.overlayBoundingRect];
        <span class="hljs-keyword">if</span> (image) {
            [<span class="hljs-keyword">self</span> setupBufferWithImage:image];
            <span class="hljs-keyword">self</span>.date = [<span class="hljs-built_in">NSDate</span> date];
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.buffer.buffer == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-keyword">self</span> generateWatermarkWithSize:<span class="hljs-keyword">self</span>.imageSize inBoundingRect:<span class="hljs-keyword">self</span>.overlayBoundingRect];
        <span class="hljs-keyword">if</span> (image) {
            [<span class="hljs-keyword">self</span> setupBufferWithImage:image];
            <span class="hljs-keyword">self</span>.date = [<span class="hljs-built_in">NSDate</span> date];
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.buffer;
}

- (<span class="hljs-built_in">UIImage</span> *)generateWatermarkWithSize:(<span class="hljs-built_in">CGSize</span>)size inBoundingRect:(<span class="hljs-built_in">CGRect</span>)boundingRect {

    ...

    <span class="hljs-comment">// Dynamic Overlay</span>
    <span class="hljs-built_in">CGRect</span> dynRealRect;
    <span class="hljs-built_in">UIImage</span> *dynamicWatermarkImage = <span class="hljs-keyword">self</span>.watermarkHttpImage;
    <span class="hljs-keyword">if</span> (dynamicWatermarkImage) {
        <span class="hljs-built_in">CGSize</span> overlaySize = dynamicWatermarkImage.size;

        <span class="hljs-built_in">CGFloat</span> height = size.height / <span class="hljs-number">3</span>;
        <span class="hljs-keyword">if</span> (overlaySize.height &gt; height) {
            overlaySize.width = height;
            overlaySize.height = height;
        }

        <span class="hljs-built_in">CGRect</span> dynOverlayRect = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, overlaySize.width, overlaySize.height);

        dynRealRect =  <span class="hljs-built_in">AVMakeRectWithAspectRatioInsideRect</span>(dynamicWatermarkImage.size, dynOverlayRect);

        dynRealRect.origin.y = padding;
        dynRealRect.origin.x = padding;
    }

    ...

}

- (<span class="hljs-keyword">void</span>)loadHTTPImageAsync {
    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), ^{
        <span class="hljs-built_in">NSData</span> *data = [[<span class="hljs-built_in">NSData</span> alloc] initWithContentsOfURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-keyword">self</span>.overlayURL]];
        <span class="hljs-keyword">if</span> ( data == <span class="hljs-literal">nil</span> )
            <span class="hljs-keyword">return</span>;
        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            <span class="hljs-keyword">self</span>.watermarkHttpImage = [<span class="hljs-built_in">UIImage</span> imageWithData:data];
        });
    });
}

...
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="initwithsession"></a><a href="#initwithsession" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>initWithSession</h3>
<p>Instead of letting the SDK manage the video and audio input, you can also do that yourself. This is helpful to supply video and audio samples which are not coming from the standard input devices. Or to modify video and/or audio samples before they are used for the stream.</p>
<p>The SDK provides a separate init method <code>initWithSession</code>.</p>
<p>An example for a custom capture session, which supplies <code>CVPixelBufferRef</code>'s to the SDK:</p>
<pre><code class="hljs css language-objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CustomCaptureSession</span> : <span class="hljs-title">AVCaptureSession</span></span>

<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVCaptureVideoDataOutput</span>* myVideoOutput;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVCaptureAudioDataOutput</span>* myAudioOutput;

...

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomCaptureSession</span></span>

- (<span class="hljs-keyword">void</span>) addOutput:(<span class="hljs-built_in">AVCaptureOutput</span> *)output {
    <span class="hljs-keyword">if</span> ([output isKindOfClass:[<span class="hljs-built_in">AVCaptureVideoDataOutput</span> <span class="hljs-keyword">class</span>]]) {
        <span class="hljs-keyword">self</span>.myVideoOutput = (<span class="hljs-built_in">AVCaptureVideoDataOutput</span>*)output;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>([output isKindOfClass:[<span class="hljs-built_in">AVCaptureAudioDataOutput</span> <span class="hljs-keyword">class</span>]]) {
        *<span class="hljs-keyword">self</span>.myAudioOutput = (<span class="hljs-built_in">AVCaptureAudioDataOutput</span>*)output; * <span class="hljs-keyword">if</span> you want to use a custom audio capture device
        [<span class="hljs-keyword">super</span> addOutput:output]; <span class="hljs-comment">// Uses the standard microphone of the iOS device</span>
    }
}

- (<span class="hljs-keyword">void</span>) addInput:(<span class="hljs-built_in">AVCaptureInput</span> *)input {
    [<span class="hljs-keyword">super</span> addInput:input]; <span class="hljs-comment">// This is required, because nanostreamAVC checks the available inputs</span>
}

- (<span class="hljs-keyword">void</span>) startRunning {
    [<span class="hljs-keyword">super</span> startRunning];
}

<span class="hljs-comment">// This method has to be called periodically - e.g. with CADisplayLink</span>
- (<span class="hljs-keyword">void</span>) supplyCMSampleBufferRef {
    CVPixelBufferRef buffer = [<span class="hljs-keyword">self</span> getCVPixelBufferRef]; <span class="hljs-comment">// Get the CVPixelBufferRef from somewhere</span>

    <span class="hljs-built_in">CMSampleBufferRef</span> newSampleBuffer = <span class="hljs-literal">NULL</span>;
    <span class="hljs-built_in">CMSampleTimingInfo</span> timingInfo = kCMTimingInfoInvalid;
    timingInfo.duration = <span class="hljs-built_in">CMTimeMake</span>(<span class="hljs-number">33</span>, <span class="hljs-number">1000</span>);    <span class="hljs-comment">// Assuming 30fps, change if otherwise</span>
    timingInfo.decodeTimeStamp = <span class="hljs-built_in">CMTimeMake</span>(ts, <span class="hljs-number">1000</span>);    <span class="hljs-comment">// Timestamp information required</span>
    timingInfo.presentationTimeStamp = timingInfo.decodeTimeStamp;

    <span class="hljs-built_in">CMVideoFormatDescriptionRef</span> videoInfo = <span class="hljs-literal">NULL</span>;
    <span class="hljs-built_in">CMVideoFormatDescriptionCreateForImageBuffer</span>(<span class="hljs-literal">NULL</span>, buffer, &amp;videoInfo);

    <span class="hljs-built_in">CMSampleBufferCreateForImageBuffer</span>(kCFAllocatorDefault, buffer, <span class="hljs-literal">true</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, videoInfo, &amp;timingInfo, &amp;newSampleBuffer);

    <span class="hljs-comment">// The following line submits the new CMSampleBufferRef to the nanostreamAVC lib</span>
    [<span class="hljs-keyword">self</span>.myVideoOutput.sampleBufferDelegate captureOutput:<span class="hljs-keyword">self</span>.myVideoOutput didOutputSampleBuffer:newSampleBuffer fromConnection:<span class="hljs-literal">nil</span>];

    <span class="hljs-built_in">CFRelease</span>(videoInfo);
    <span class="hljs-built_in">CFRelease</span>(buffer);
    <span class="hljs-built_in">CFRelease</span>(newSampleBuffer);
}

<span class="hljs-keyword">@end</span>

<span class="hljs-comment">// You need to use initWithSession for nanostreamAVC to use your custom session</span>

...

session = [[CustomCaptureSession alloc] init];

<span class="hljs-comment">// Use microphone from iOS device as audio source</span>
<span class="hljs-built_in">NSError</span> *error;
<span class="hljs-built_in">AVCaptureInput</span> *audioInput = [<span class="hljs-built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:[<span class="hljs-built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="hljs-built_in">AVMediaTypeAudio</span>] error:&amp;error];

<span class="hljs-keyword">if</span> (audioInput != <span class="hljs-literal">nil</span>) {
    [session addInput:audioInput]; <span class="hljs-comment">// If the stream should be video only, don't add an audioInput</span>
}

[session startRunning];

...

<span class="hljs-keyword">self</span>.stream = [[nanostreamAVC alloc] initWithSession:session settings:nAVCSettings eventListener:<span class="hljs-keyword">self</span>];

...
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="specific-use-cases"></a><a href="#specific-use-cases" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Specific use cases</h2>
<h3><a class="anchor" aria-hidden="true" id="stream-from-a-gopro"></a><a href="#stream-from-a-gopro" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stream from a GoPro</h3>
<p>Instead of using the build-in camera and microphone of an iOS device, it is also possible to use external devices like a GoPro camera.</p>
<p>To use this feature you will need a special build of our SDK. Please contact us for more information.</p>
<p>The following pseudo code shows how to use a GoPro camera as source:</p>
<pre><code class="hljs css language-objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"nanostreamAVCExternals.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">YourLiveViewController</span> `&lt;<span class="hljs-title">nanostreamEventListener</span>, <span class="hljs-title">ExtendedCaptureSessionStatusListener</span>&gt;`</span>

...

<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) nanostreamAVC *stream;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVCaptureSession</span> *session;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIView</span> *cameraView;

...

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">YourLiveViewController</span></span>

...

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.cameraSource == GoProHero3) {
    <span class="hljs-keyword">self</span>.session = [[HLSCaptureSession alloc] initWithPreview:cameraView andStatusListener:<span class="hljs-keyword">self</span> andUDP:<span class="hljs-literal">NO</span>];

}
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.cameraSource == GoProHero4) {
    <span class="hljs-keyword">self</span>.session = [[HLSCaptureSession alloc] initWithPreview:cameraView andStatusListener:<span class="hljs-keyword">self</span> andUDP:<span class="hljs-literal">YES</span>];
}

[<span class="hljs-keyword">self</span>.session startRunning];

<span class="hljs-comment">// Set up settings for nanostreamAVC</span>

...

<span class="hljs-keyword">self</span>.stream = [[nanostreamAVC alloc] initWithSession:<span class="hljs-keyword">self</span>.session
                                            settings:nAVCSettings
                                       eventListener:<span class="hljs-keyword">self</span>];

...

<span class="hljs-keyword">@end</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="stream-from-a-drone"></a><a href="#stream-from-a-drone" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stream from a Drone</h3>
<p>Get in touch with us to learn how to send a live stream from a Drone (Parrot Bebop or DJI)</p>
<h2><a class="anchor" aria-hidden="true" id="possible-issues"></a><a href="#possible-issues" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Possible Issues</h2>
<h3><a class="anchor" aria-hidden="true" id="general"></a><a href="#general" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>General</h3>
<p>For older versions of the sdk, without support for <code>arm64</code>, architecture in <code>Xcode</code> has to be set to <code>armv7</code> and/or <code>armv7s</code>. This works also for newer iOS-Devcies like iPhone 5s.</p>
<p><strong>This is not required for newer sdk versions</strong>, which also support <code>arm64</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="compilerlinker"></a><a href="#compilerlinker" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compiler/Linker</h3>
<h4><a class="anchor" aria-hidden="true" id="libstdc"></a><a href="#libstdc" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>libstdc++</h4>
<p>If there are linker errors with <code>std::: &quot;symbol(s) not found for architecture&quot;</code>, make sure that you added the libraries <code>libstdc++.dylib</code> and <code>libc++.dylib</code> to your project.</p>
<p>Due to a bug in Xcode, depending on the selected Base SDK and deployment target, there might be still linker errors regarding &quot;std&quot;. In this case you need to add a specific version of the libstdc++ to your project, e.g.: libstdc++-6.0.9.dylib instead of libstdc++.dylib</p>
<h4><a class="anchor" aria-hidden="true" id="undefined-symbols-for-parrot--dji"></a><a href="#undefined-symbols-for-parrot--dji" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Undefined Symbols for Parrot &amp; DJI</h4>
<p><strong>The following part is only relevant for SDK versions from 3.3.x to 4.1.x.</strong>
As of version 4.2.x the drone dependencies are removed from the standard SDK package.</p>
<p>It might be possible that there are linker errors for the classes</p>
<ul>
<li><p><code>ParrotBebopCaptureSession</code> or</p></li>
<li><p><code>DJIPhantom2CaptureSession</code></p></li>
</ul>
<p>Generally, if the Parrot &amp; DJI extensions are not used, the symbols should be stripped automatically by <code>Xcode</code> and you do not need to link the frameworks.
However this is not the case when the linker flag -<code>ObjC</code> is used in the app project. This causes the linker to load all symbols included in all linked object files (including the Parrot &amp; DJI symbols). This prevents the automatic stripping.</p>
<p>To use our library without Parrot &amp; DJI, either remove the -<code>ObjC</code> linker flag from the project or replace the -<code>ObjC</code> linker flag with the <code>-force_load</code> flag for each library that you want to use. Do not use <code>-force_load</code> with <code>libnanostreamAVC.a</code>.</p>
<p>For examples <a href="http://stackoverflow.com/questions/11254269/using-the-force-load-linker-flag-with-restkit-ios">see</a></p>
<h4><a class="anchor" aria-hidden="true" id="duplicate-symbols"></a><a href="#duplicate-symbols" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Duplicate Symbols</h4>
<p>If there are duplicate symbol errors, check the &quot;Other Linker Flags&quot; setting. Select a target, go to &quot;Build Settings&quot; and type into the search field &quot;Other Linker Flags&quot;.</p>
<p>Check if the linker flag <code>-all_load</code> is used. Either remove the flag or if you have to use it, consider using the flag <code>-force_load</code> or <code>-ObjC</code> instead.</p>
<p><a href="http://stackoverflow.com/questions/3354864/xcode-project-target-settings-syntax-for-linker-flag-force-load-on-iphone">See also here for more information on the &quot;-force_load&quot; flag</a></p>
<p><a href="https://developer.apple.com/library/mac/qa/qa1490/_index.html">Check also this information if you have a &quot;selector not recognized&quot; runtime exception</a></p>
<h3><a class="anchor" aria-hidden="true" id="breakpoints"></a><a href="#breakpoints" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Breakpoints</h3>
<p>If you debug your application, it is possible that breakpoints are being hit due to internal exceptions. Exceptions on the SDK level are handled in the SDK and do not affect the workflow of your application.</p>
<p>You can prevent the breakpoint from pausing the workflow of your application, if you use the right settings for the breakpoint.
The default setting is most likely that every exception causes a break.
To change that, use the settings from the following screenshot:</p>
<p><img src="/img/nanostream/ios/screenshot_exception_breakpoint.png" alt="Screenshot"></p>
<p>This way only <code>Objective-C exceptions</code> will be catched and <code>C++ exceptions</code> will be ignored.</p>
<h3><a class="anchor" aria-hidden="true" id="crashes"></a><a href="#crashes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Crashes</h3>
<h4><a class="anchor" aria-hidden="true" id="calayergetdelegate--calayergetsuperlayer--other-calayer"></a><a href="#calayergetdelegate--calayergetsuperlayer--other-calayer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CALayerGetDelegate / CALayerGetSuperlayer / Other CALayer</h4>
<p>If there are crashes occurring in your app that include above symbols in the stack trace and are otherwise not obvious, check to see if you added a subviews to the preview view. The <code>UIView</code> instance that is passed to</p>
<pre><code class="hljs css language-objc">- [RtmpSourceCaptureSession initWithPreview:andStatusListener:andLogLevel:]
</code></pre>
<p>and</p>
<pre><code class="hljs css language-objc">- [nanostreamAVC initWithSettings:uiPreview:eventListener:]
</code></pre>
<p>cannot contain any subviews (UIButtons or otherwise).</p>
<h2><a class="anchor" aria-hidden="true" id="logging-information"></a><a href="#logging-information" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Logging Information</h2>
<p>If you encounter a problem with the <code>nanostreamAVC</code> library and you want to report the problem, log files will help us to comprehend the problem.</p>
<p>Please use the following steps to create the log files:</p>
<ul>
<li><strong>for the encoder (nanostreamAVC)</strong>: enable logging for the library with the method &quot;SetLogLevel&quot;, use LogLevelCustomSupport (if not available use LogLevelVerbose):</li>
</ul>
<pre><code class="hljs css language-objc">[<span class="hljs-keyword">self</span>.nAVC SetLogLevel:LogLevelCustomSupport];  <span class="hljs-comment">// set the log level before the method "start" is invoked</span>
</code></pre>
<ul>
<li><strong>for the player (RtmpSourceCaptureSession)</strong>: the log level has to be set in the constructor:</li>
</ul>
<pre><code class="hljs css language-objc"><span class="hljs-keyword">self</span>.session = [[RtmpSourceCaptureSession alloc] initWithPreview:<span class="hljs-keyword">self</span>.playerView andStatusListener:<span class="hljs-keyword">self</span> andLogLevel:LogLevelCustomSupport];
</code></pre>
<ul>
<li><p>try to reproduce the problem</p></li>
<li><p>download the app container (for your app) from the iOS device with <code>Xcode</code>, as explained <a href="http://help.apple.com/xcode/mac/8.0/#/dev816c242e1">here</a></p></li>
<li><p>in Finder right click on the downloaded container and select <code>Show Package Contents</code></p></li>
<li><p>send us <strong>all</strong> log files located (in the container) in the folder <code>/AppData/Library/Caches/Logs/</code></p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="crash-logs"></a><a href="#crash-logs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Crash Logs</h2>
<p>If you encounter a crash, please send us the crash log as explained in the following steps:</p>
<ul>
<li>Plug in the device and open <code>Xcode</code></li>
<li>Choose <code>Window --&gt; Devices</code> from the menu bar</li>
<li>Under the DEVICES section in the left column, choose the device</li>
<li>To see the device console, click the up-triangle at the bottom left of the right hand panel</li>
<li>Click the down arrow on the bottom right to save the console as a file</li>
<li>To see crash logs, select the View Device Logs button under the Device Information section on the right hand panel</li>
<li><strong>Wait until the Scanning Process is complete</strong>, this can take a while (there should be a text at the top of the Window, something like &quot;Scanning '...crash'...&quot;)</li>
<li>Use the column <code>Date/Time</code> to order the crashes after dates.</li>
<li>Find your app in the Process column and select the Crash log to see the contents.</li>
<li>To save a crash log, right click the entry on the left column and choose <code>Export Log</code></li>
</ul>
<p>Taken from <a href="https://developer.apple.com/library/ios/qa/qa1747/_index.html">here</a></p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 9/16/2022</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/nanostream/ios/nanostream-ios-step-by-step"><span class="arrow-prev">← </span><span>Getting started</span></a><a class="docs-next button" href="/docs/nanostream/ios/bintu_ios_sdk"><span>bintu.live client SDK</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#purpose">Purpose</a></li><li><a href="#requirements">Requirements</a></li><li><a href="#getting-started">Getting Started</a><ul class="toc-headings"><li><a href="#preparation">Preparation</a></li><li><a href="#check-library-version">Check library version</a></li><li><a href="#initialize-the-library-for-broadcasting">Initialize the library for broadcasting</a></li><li><a href="#start-a-stream">Start a stream</a></li><li><a href="#stop-a-running-stream">Stop a running stream</a></li></ul></li><li><a href="#live-playback">Live Playback</a><ul class="toc-headings"><li><a href="#initialize-the-library-for-playback">Initialize the library for playback</a></li><li><a href="#start-playback">Start playback</a></li></ul></li><li><a href="#advanced-settingsusage">Advanced Settings/Usage</a><ul class="toc-headings"><li><a href="#meaning-of-events-and-errors-nanostreamevent">Meaning of Events and Errors (nanostreamEvent)</a></li><li><a href="#switch-camera">Switch Camera</a></li><li><a href="#orientation">Orientation</a></li><li><a href="#stream-type">Stream Type</a></li><li><a href="#zoom">Zoom</a></li><li><a href="#server-authentication">Server Authentication</a></li><li><a href="#local-recording">Local Recording</a></li><li><a href="#cropping">Cropping</a></li><li><a href="#adaptive-bitrate">Adaptive Bitrate</a></li><li><a href="#statistics-during-streaming">Statistics during streaming</a></li><li><a href="#measuring-the-available-bandwidth">Measuring the available bandwidth</a></li><li><a href="#snaphot-from-the-current-stream">Snaphot from the current stream</a></li><li><a href="#overlaywatermark">Overlay/Watermark</a></li><li><a href="#initwithsession">initWithSession</a></li></ul></li><li><a href="#specific-use-cases">Specific use cases</a><ul class="toc-headings"><li><a href="#stream-from-a-gopro">Stream from a GoPro</a></li><li><a href="#stream-from-a-drone">Stream from a Drone</a></li></ul></li><li><a href="#possible-issues">Possible Issues</a><ul class="toc-headings"><li><a href="#general">General</a></li><li><a href="#compilerlinker">Compiler/Linker</a></li><li><a href="#breakpoints">Breakpoints</a></li><li><a href="#crashes">Crashes</a></li></ul></li><li><a href="#logging-information">Logging Information</a></li><li><a href="#crash-logs">Crash Logs</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><div><h5>Contact</h5><a href="https://www.nanocosmos.de/">Homepage</a><a href="https://www.nanocosmos.de/contact">Contact</a><a href="https://www.nanocosmos.de/support">Support</a><a href="https://www.nanocosmos.de/terms">Legal Terms</a></div><div><h5>Products</h5><a href="https://www.nanocosmos.de/cloud">Nanostream Cloud with Bintu.Live</a><a href="https://www.nanocosmos.de/h5live">H5Live Low Latency HTML5-Player</a><a href="https://www.nanocosmos.de/webrtc">nanoStream Webcaster</a><a href="https://www.nanocosmos.de/#nanostream">Nanostream Apps and SDK</a></div><div><h5>More</h5><a href="https://www.nanocosmos.de/blog/">Blog</a><a href="https://twitter.com/nanovideo">Twitter</a><a href="https://www.facebook.com/nanocosmos.net/">Facebook</a><a href="https://www.linkedin.com/company/nanocosmos-gmbh">LinkedIn</a><a href="https://github.com/nanocosmos/docs">GitHub</a><a class="github-button" href="https://github.com/nanocosmos/docs" data-icon="octicon-star" data-count-href="/nanocosmos/docs/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://nanocosmos.de/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/img/footer_logo.png" alt="nanocosmos GmbH" width="170" height="45"/></a><section class="copyright">Copyright © 2022 nanocosmos GmbH - doc version Fri Sep 16 2022 01:34:42 GMT+0000 (Coordinated Universal Time)</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typesense-docsearch.js@latest/dist/cdn/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                inputSelector: '#search_input_react',
                typesenseServerConfig: {"nodes":[{"host":"typesense.nanostream.cloud","port":"443","protocol":"https"}],"apiKey":"VXsRNvH2cHHs5uVOk74gX8jDtWTTVKsV"},
                typesenseCollectionName: "nanocosmos",
                typesenseSearchParams: {"per_page":20},
                debug: true,
              });
              </script></body></html>